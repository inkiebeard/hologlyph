<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hologlyph Editor</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a2e;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        .editor-layout {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        .sidebar {
            display: flex;
            background: #0f0f1e;
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            z-index: 100;
        }
        
        .toolbar {
            width: 60px;
            background: #0a0a14;
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            gap: 5px;
        }
        
        .tool-button {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: #8b8b9e;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .tool-button span {
            font-size: 9px;
            margin-top: 2px;
        }
        
        .tool-button:hover {
            background: #1a1a2e;
            color: #fff;
        }
        
        .tool-button.active {
            background: #667eea;
            color: #fff;
        }
        
        .tool-button.active::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 40px;
            background: #fff;
        }
        
        .panel-container {
            width: 340px;
            overflow-y: auto; /* Allow scrolling when panels are too tall */
            overflow-x: hidden;
            background: #0f0f1e;
            display: flex;
            flex-direction: column;
        }
        
        .panel {
            display: none;
            flex-shrink: 0;
            background: #0f0f1e;
            border-bottom: 1px solid #2a2a3e;
            overflow-y: auto;
            overflow-x: hidden;
            color: #fff;
            min-height: 200px;
            position: relative;
        }
        
        .panel.active {
            display: flex;
            flex-direction: column;
        }
        
        .panel-content {
            padding: 1.5rem;
            flex: 1;
            overflow-y: auto;
        }
        
        .panel-resize-handle {
            height: 0;
            background: #1a1a2e;
            cursor: ns-resize;
            border-top: 1px solid #2a2a3e;
            border-bottom: 1px solid #2a2a3e;
            transition: all 0.2s;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }
        
        .panel.active + .panel-resize-handle {
            height: 8px;
        }
        
        .panel-resize-handle::after {
            content: '‚ãÆ';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            color: #4a5568;
            font-size: 12px;
            transition: color 0.2s;
        }
        
        .panel-resize-handle:hover {
            background: #667eea;
        }
        
        .panel-resize-handle:hover::after {
            color: #fff;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: #1a1a2e;
            border-bottom: 1px solid #2a2a3e;
            flex-shrink: 0;
        }
        
        .panel-header h2 {
            color: #fff;
            font-size: 1.1rem;
            margin: 0;
            padding: 0;
            border: none;
        }
        
        .panel-close {
            background: none;
            border: none;
            color: #8b8b9e;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .panel-close:hover {
            color: #fff;
        }
        
        .panel h2 {
            color: #fff;
            font-size: 1.3rem;
            margin-bottom: 1.2rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Important for flexbox to work properly */
        }
        
        .canvas-container {
            flex: 1;
            min-height: 0; /* Allows container to shrink below content size */
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #4a5568;
            background: #0f0f1e;
            cursor: crosshair;
        }
        
        /* Remove crosshair - using mouse position instead */
        
        /* Axis indicator overlay */
        .axis-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s ease;
        }
        
        .axis-arrow {
            position: absolute;
            left: 50px;
            top: 50px;
            transform-origin: 0 0;
            transition: all 0.1s ease;
        }
        
        .axis-arrow-line {
            width: 40px;
            height: 3px;
            position: absolute;
        }
        
        .axis-arrow-head {
            position: absolute;
            right: -8px;
            top: 50%;
            width: 0;
            height: 0;
            border-left: 8px solid;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            transform: translateY(-50%);
        }
        
        .axis-label {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.9), 0 0 6px rgba(0, 0, 0, 0.6);
            transition: all 0.1s ease;
        }
        
        .bottom-panel {
            background: #0f0f1e;
            padding: 1rem 1.5rem;
            border-top: 1px solid #2a2a3e;
            color: #fff;
            flex-shrink: 0; /* Prevent bottom panel from shrinking */
        }
        
        .field label.label {
            color: #ddd;
            font-weight: 500;
        }
        
        .label.is-small {
            color: #bbb;
            font-size: 0.8rem;
        }
        
        .color-preview {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            border: 2px solid #4a5568;
            margin-top: 0.5rem;
        }
        
        .input, .select select {
            background: #1a1a2e;
            border-color: #4a5568;
            color: #fff;
        }
        
        .input:focus, .select select:focus {
            border-color: #667eea;
        }
        
        .button {
            font-weight: 600;
        }
        
        .table {
            background: transparent;
            color: #ddd;
        }
        
        .table td, .table th {
            border-color: #2a2a3e;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0a0a14;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #667eea;
        }

        #savedProjectsList .box {
            transition: all 0.2s;
        }

        #savedProjectsList .box:hover {
            border-color: #667eea !important;
        }

        /* Slider Styles */
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a2e;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            border: 1px solid #4a5568;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #7c8ef5;
            transform: scale(1.1);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            background: #5568d3;
            transform: scale(0.95);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #7c8ef5;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb:active {
            background: #5568d3;
            transform: scale(0.95);
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a2e;
            border: 1px solid #4a5568;
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a2e;
            border: 1px solid #4a5568;
        }

        input[type="range"]:focus {
            outline: none;
        }

        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        input[type="range"]:focus::-moz-range-thumb {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        /* Custom Slider Control Component */
        .slider-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .slider-control-label {
            color: #ddd;
            font-weight: 500;
            font-size: 0.9rem;
            margin: 0;
        }

        .slider-control-value {
            background: #1a1a2e;
            border: 1px solid #4a5568;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            font-size: 0.85rem;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            transition: all 0.2s;
        }

        .slider-control-value:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        .slider-control-value:hover {
            border-color: #667eea;
        }

        .slider-control-track {
            position: relative;
            display: flex;
            align-items: center;
        }

        /* Remove spinner buttons from number inputs in slider controls */
        .slider-control-value::-webkit-inner-spin-button,
        .slider-control-value::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .slider-control-value {
            -moz-appearance: textfield;
            appearance: textfield;
        }
    </style>
</head>
<body>
    <div class="editor-layout">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Toolbar -->
            <div class="toolbar">
                <button class="tool-button active" data-panel="project">
                    ‚öôÔ∏è<span>Project</span>
                </button>
                <button class="tool-button" data-panel="shape">
                    üì¶<span>Shape</span>
                </button>
                <button class="tool-button" data-panel="color">
                    üé®<span>Color</span>
                </button>
                <button class="tool-button" data-panel="voxel">
                    ‚úèÔ∏è<span>Voxel</span>
                </button>
                <button class="tool-button" data-panel="camera">
                    üì∑<span>Camera</span>
                </button>
                <button class="tool-button" data-panel="stats">
                    üìä<span>Stats</span>
                </button>
                <button class="tool-button" data-panel="image">
                    üñºÔ∏è<span>Image</span>
                </button>
                <button class="tool-button" data-panel="file">
                    üíæ<span>File</span>
                </button>
            </div>
            
            <!-- Panels Container -->
            <div class="panel-container">
                <!-- Project Settings Panel -->
                <div class="panel active" id="project-panel" style="height: 400px;">
                    <div class="panel-header">
                        <h2>Project Settings</h2>
                        <button class="panel-close" data-panel="project">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Grid Size</label>
                        <div class="columns is-mobile is-gapless">
                            <div class="column">
                                <label class="label is-small">Width</label>
                                <input class="input is-small" type="number" id="gridWidth" value="64" min="1" max="255">
                            </div>
                            <div class="column ml-2">
                                <label class="label is-small">Height</label>
                                <input class="input is-small" type="number" id="gridHeight" value="128" min="1" max="255">
                            </div>
                            <div class="column ml-2">
                                <label class="label is-small">Depth</label>
                                <input class="input is-small" type="number" id="gridDepth" value="64" min="1" max="255">
                            </div>
                        </div>
                    </div>

                    <div class="field">
                        <label class="label">Frame Count</label>
                        <input class="input" type="number" id="frameCount" value="1" min="1" max="100">
                    </div>

                    <div class="field">
                        <label class="label">Frame Duration (ms)</label>
                        <input class="input" type="number" id="frameDuration" value="100" min="10" max="5000">
                    </div>

                    <div class="field">
                        <label class="checkbox">
                            <input type="checkbox" id="loopAnimation" checked>
                            Loop Animation
                        </label>
                    </div>

                    <button class="button is-primary is-fullwidth" id="createProject">
                        Create New Project
                    </button>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="project"></div>

                <!-- Shape Generator Panel -->
                <div class="panel" id="shape-panel" style="height: 450px;">
                    <div class="panel-header">
                        <h2>Shape Generator</h2>
                        <button class="panel-close" data-panel="shape">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Shape Type</label>
                        <div class="select is-fullwidth">
                            <select id="shapeType">
                                <option value="cube">Cube</option>
                                <option value="box">Rectangular Prism</option>
                                <option value="sphere">Sphere</option>
                                <option value="pyramid">Pyramid (Square Base)</option>
                                <option value="cone">Cone</option>
                                <option value="cylinder">Cylinder</option>
                            </select>
                        </div>
                    </div>

                    <div class="field">
                        <label class="label">Center Position (X, Y, Z)</label>
                        <div class="columns is-mobile is-gapless">
                            <div class="column">
                                <input class="input is-small" type="number" id="shapePosX" value="8" min="0">
                            </div>
                            <div class="column ml-2">
                                <input class="input is-small" type="number" id="shapePosY" value="8" min="0">
                            </div>
                            <div class="column ml-2">
                                <input class="input is-small" type="number" id="shapePosZ" value="8" min="0">
                            </div>
                        </div>
                    </div>

                    <div class="field">
                        <label class="label">Dimensions</label>
                        <div class="columns is-mobile is-gapless">
                            <div class="column">
                                <label class="label is-small" id="shapeWidthLabel">Width</label>
                                <input class="input is-small" type="number" id="shapeWidth" value="4" min="1">
                            </div>
                            <div class="column ml-2" id="shapeHeightContainer">
                                <label class="label is-small">Height</label>
                                <input class="input is-small" type="number" id="shapeHeight" value="4" min="1">
                            </div>
                            <div class="column ml-2" id="shapeDepthContainer">
                                <label class="label is-small">Depth</label>
                                <input class="input is-small" type="number" id="shapeDepth" value="4" min="1">
                            </div>
                        </div>
                    </div>

                    <div class="field">
                        <label class="checkbox">
                            <input type="checkbox" id="shapeFilled" checked>
                            Filled (uncheck for hollow)
                        </label>
                    </div>

                    <button class="button is-primary is-fullwidth" id="generateShape">
                        Generate Shape
                    </button>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="shape"></div>

                <!-- Color Picker Panel -->
                <div class="panel active" id="color-panel" style="height: 550px;">
                    <div class="panel-header">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                            <h2 style="margin: 0;">Color Picker</h2>
                            <div class="color-preview" id="sharedColorPreview" style="width: 32px; height: 32px; margin: 0;"></div>
                        </div>
                        <button class="panel-close" data-panel="color">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Click to Pick Color</label>
                        <canvas id="colorPickerCanvas" width="280" height="280" style="border: 2px solid #4a5568; border-radius: 4px; cursor: crosshair; display: block;"></canvas>
                        <p class="help">Click anywhere to select hue & saturation</p>
                    </div>

                    <div class="field">
                        <div class="columns is-mobile is-gapless">
                            <div class="column mr-2">
                                <div class="slider-control">
                                    <div class="slider-control-header">
                                        <label class="slider-control-label">Brightness</label>
                                        <input class="slider-control-value" type="number" id="colorBrightValue" min="0" max="100" value="50">
                                    </div>
                                    <div class="slider-control-track">
                                        <input type="range" id="colorBright" min="0" max="100" value="50">
                                    </div>
                                </div>
                            </div>
                            <div class="column">
                                <div class="slider-control">
                                    <div class="slider-control-header">
                                        <label class="slider-control-label">Alpha</label>
                                        <input class="slider-control-value" type="number" id="colorAlphaValue" min="0" max="100" value="100">
                                    </div>
                                    <div class="slider-control-track">
                                        <input type="range" id="colorAlpha" min="0" max="100" value="100">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="field">
                        <label class="label">Exact Values (optional)</label>
                        <div class="columns is-mobile is-gapless">
                            <div class="column mr-1">
                                <label class="label is-small">Hue</label>
                                <input class="input is-small" type="number" id="colorHue" min="0" max="255" value="128">
                            </div>
                            <div class="column mr-1">
                                <label class="label is-small">Saturation</label>
                                <input class="input is-small" type="number" id="colorSat" min="0" max="100" value="100">
                            </div>
                        </div>
                    </div>

                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="color"></div>

                <!-- Voxel Editor Panel -->
                <div class="panel" id="voxel-panel" style="height: 550px;">
                    <div class="panel-header">
                        <h2>Voxel Editor</h2>
                        <button class="panel-close" data-panel="voxel">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="notification" style="background: rgba(102, 126, 234, 0.1); border: 1px solid #667eea; padding: 0.75rem; margin-bottom: 1rem;">
                        <p style="font-size: 0.85rem; margin-bottom: 0.5rem;"><strong>üéÆ Interactive Mode:</strong></p>
                        <p style="font-size: 0.75rem; color: #ddd;">
                            ‚Ä¢ <strong>Purple voxel</strong> shows cursor position<br>
                            ‚Ä¢ <strong>Point & click</strong> to place anywhere<br>
                            ‚Ä¢ <strong>Right-click</strong> to remove<br>
                            ‚Ä¢ <strong>W/S</strong> forward/back | <strong>A/D</strong> left/right<br>
                            ‚Ä¢ <strong>Q/E</strong> down/up | <strong>Space</strong> place<br>
                            ‚Ä¢ <strong>Drag</strong> rotate | <strong>Shift+Drag</strong> pan<br>
                            ‚Ä¢ <strong>Wheel</strong> zoom | <strong>R</strong> reset pan<br>
                            ‚Ä¢ <strong>O</strong> toggle onion skin (blue=past, red=future)<br>
                            ‚Ä¢ <strong>G</strong> toggle bounding box grid
                        </p>
                    </div>
                    
                    <div class="field">
                        <label class="label">Manual Position Control</label>
                        
                        <label class="label is-small">X</label>
                        <input class="slider is-fullwidth is-small" type="range" id="voxelXSlider" min="0" max="15" value="0">
                        <input class="input is-small mt-1" type="number" id="voxelX" value="0" min="0">
                        
                        <label class="label is-small mt-3">Y</label>
                        <input class="slider is-fullwidth is-small" type="range" id="voxelYSlider" min="0" max="15" value="0">
                        <input class="input is-small mt-1" type="number" id="voxelY" value="0" min="0">
                        
                        <label class="label is-small mt-3">Z</label>
                        <input class="slider is-fullwidth is-small" type="range" id="voxelZSlider" min="0" max="15" value="0">
                        <input class="input is-small mt-1" type="number" id="voxelZ" value="0" min="0">
                    </div>

                    <button class="button is-success is-fullwidth mt-4" id="setVoxel">
                        Set Voxel (or press Space)
                    </button>
                    
                    <button class="button is-warning is-fullwidth mt-2" id="clearVoxel">
                        Clear Voxel (or press Delete)
                    </button>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="voxel"></div>

                <!-- Camera Panel -->
                <div class="panel" id="camera-panel" style="height: 350px;">
                    <div class="panel-header">
                        <h2>Camera View</h2>
                        <button class="panel-close" data-panel="camera">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Rotation X (Vertical)</label>
                        <input class="input" type="number" id="cameraRotX" value="0.3" step="0.1" min="-1.57" max="1.57">
                    </div>
                    
                    <div class="field">
                        <label class="label">Rotation Y (Horizontal)</label>
                        <input class="input" type="number" id="cameraRotY" value="0.6" step="0.1">
                    </div>

                    <div class="field">
                        <div class="slider-control">
                            <div class="slider-control-header">
                                <label class="slider-control-label">Zoom Level</label>
                                <input class="slider-control-value" type="number" id="cameraZoomValue" min="0.3" max="3" value="1" step="0.1">
                            </div>
                            <div class="slider-control-track">
                                <input type="range" id="cameraZoom" min="0.3" max="3" value="1" step="0.1">
                            </div>
                        </div>
                    </div>
                    
                    <button class="button is-info is-fullwidth" id="resetCamera">Reset Camera</button>
                    
                    <p class="help mt-2">üí° Use mouse wheel or pinch to zoom</p>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="camera"></div>

                <!-- Statistics Panel -->
                <div class="panel" id="stats-panel" style="height: 250px;">
                    <div class="panel-header">
                        <h2>Statistics</h2>
                        <button class="panel-close" data-panel="stats">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <table class="table is-fullwidth is-size-7">
                        <tbody>
                            <tr>
                                <td><strong>Current Frame:</strong></td>
                                <td id="statsCurrentFrame">-</td>
                            </tr>
                            <tr>
                                <td><strong>Voxels Set:</strong></td>
                                <td id="statsVoxelCount">0</td>
                            </tr>
                            <tr>
                                <td><strong>Frame Size:</strong></td>
                                <td id="statsFrameSize">0 bytes</td>
                            </tr>
                            <tr>
                                <td><strong>Total Size:</strong></td>
                                <td id="statsTotalSize">0 bytes</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="stats"></div>

                <!-- Image Import Panel -->
                <div class="panel" id="image-panel" style="height: 400px;">
                    <div class="panel-header">
                        <h2>Trace Image</h2>
                        <button class="panel-close" data-panel="image">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Import Reference Image</label>
                        <div class="file is-fullwidth">
                            <label class="file-label">
                                <input class="file-input" type="file" id="importImage" accept="image/*">
                                <span class="file-cta is-fullwidth">
                                    <span class="file-icon">üñºÔ∏è</span>
                                    <span class="file-label">Choose Image...</span>
                                </span>
                            </label>
                        </div>
                        <p class="help mt-2">Upload an image to use as a tracing reference, or drag & drop onto the canvas</p>
                    </div>

                    <div class="field" id="imagePreviewContainer" style="display: none; margin-top: 1rem;">
                        <label class="label">Image Preview</label>
                        <div id="imagePreviewDropZone" style="border: 2px solid #4a5568; border-radius: 4px; padding: 8px; background: #1a1a2e; text-align: center; min-height: 100px; position: relative;">
                            <img id="imagePreview" style="max-width: 100%; max-height: 150px; border-radius: 4px; display: none;" alt="Trace image preview">
                            <p class="help mt-2" id="imagePreviewInfo">No image loaded</p>
                            <div id="imagePreviewDropOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(102, 126, 234, 0.1); border: 2px dashed #667eea; border-radius: 4px; display: none; align-items: center; justify-content: center; pointer-events: none;">
                                <span style="color: #667eea; font-weight: bold;">Drop image here</span>
                            </div>
                        </div>
                    </div>

                    <div class="field" id="imageControls" style="display: none;">
                        <label class="label">Image Controls</label>
                        
                        <div class="field">
                            <label class="label is-small">Opacity</label>
                            <input class="input" type="range" id="imageOpacity" min="0" max="100" value="50" step="5">
                            <p class="help"><span id="imageOpacityValue">50</span>%</p>
                        </div>

                        <div class="field">
                            <label class="label is-small">Scale</label>
                            <input class="input" type="range" id="imageScale" min="25" max="200" value="100" step="5">
                            <p class="help"><span id="imageScaleValue">100</span>%</p>
                        </div>

                        <div class="field">
                            <label class="label is-small">Position X</label>
                            <input class="input" type="range" id="imagePosX" min="-100" max="100" value="0" step="5">
                            <p class="help"><span id="imagePosXValue">0</span>px</p>
                        </div>

                        <div class="field">
                            <label class="label is-small">Position Y</label>
                            <input class="input" type="range" id="imagePosY" min="-100" max="100" value="0" step="5">
                            <p class="help"><span id="imagePosYValue">0</span>px</p>
                        </div>

                        <div class="buttons">
                            <button class="button is-danger is-fullwidth" id="clearImage">
                                üóëÔ∏è Clear Image
                            </button>
                        </div>
                    </div>
                    </div>
                </div>
                <div class="panel-resize-handle" data-panel="image"></div>

                <!-- File Operations Panel -->
                <div class="panel" id="file-panel" style="height: 500px;">
                    <div class="panel-header">
                        <h2>File Operations</h2>
                        <button class="panel-close" data-panel="file">‚úï</button>
                    </div>
                    <div class="panel-content">
                    
                    <div class="field">
                        <label class="label">Project Name</label>
                        <input class="input" type="text" id="projectName" placeholder="My Project" value="Untitled">
                    </div>

                    <div class="buttons">
                        <button class="button is-success is-fullwidth" id="saveProject">
                            üíæ Save Project
                        </button>
                    </div>

                    <div class="field">
                        <label class="checkbox">
                            <input type="checkbox" id="autoSaveEnabled" checked>
                            Auto-save on changes (2 second delay)
                        </label>
                        <p class="help mt-2">Last saved: <span id="lastSaveTime">Never</span></p>
                        <p class="help">Automatically saves when you place voxels or modify frames</p>
                    </div>

                    <hr style="background: #2a2a3e; margin: 1rem 0;">

                    <div class="field">
                        <label class="label">Saved Projects</label>
                        <div id="savedProjectsList" style="max-height: 200px; overflow-y: auto;">
                            <p class="help">No saved projects</p>
                        </div>
                    </div>

                    <hr style="background: #2a2a3e; margin: 1rem 0;">
                    
                    <div class="field">
                        <label class="checkbox">
                            <input type="checkbox" id="exportCompress" checked>
                            Compress with RLE (reduces file size)
                        </label>
                    </div>
                    
                    <button class="button is-info is-fullwidth mb-2" id="exportFile">
                        üì§ Export .glyf File
                    </button>
                    
                    <div class="file is-fullwidth">
                        <label class="file-label">
                            <input class="file-input" type="file" id="importFile" accept=".glyf">
                            <span class="file-cta is-fullwidth">
                                <span class="file-icon">üìÅ</span>
                                <span class="file-label">Import .glyf File</span>
                            </span>
                        </label>
                    </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="canvas-container" id="canvasContainer" style="position: relative;">
                <!-- Background image for tracing (not a canvas) -->
                <img id="traceImage" style="position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; display: none; max-width: 800px; max-height: 800px;" alt="Trace reference">
                <!-- Main preview canvas (WebGL) - only canvas allowed -->
                <canvas id="previewCanvas" width="800" height="800" style="position: relative; z-index: 2;"></canvas>
                <!-- Drag and drop overlay -->
                <div id="dragDropOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; background: rgba(102, 126, 234, 0.2); border: 3px dashed #667eea; display: none; align-items: center; justify-content: center; pointer-events: none; transition: all 0.2s;">
                    <div style="color: #fff; font-size: 24px; font-weight: bold; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">üìÅ</div>
                        <div>Drop image here to trace</div>
                    </div>
                </div>
                <!-- Drag and drop overlay - accepted state -->
                <div id="dragDropOverlayAccepted" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; background: rgba(72, 199, 116, 0.3); border: 3px solid #48c774; display: none; align-items: center; justify-content: center; pointer-events: none; transition: all 0.2s;">
                    <div style="color: #fff; font-size: 24px; font-weight: bold; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">‚úÖ</div>
                        <div>Release to import image</div>
                    </div>
                </div>
                
                <!-- Axis indicator overlay -->
                <div class="axis-overlay">
                    <!-- X axis (red) -->
                    <div class="axis-arrow" id="axisX">
                        <div class="axis-arrow-line" style="background: #ff4444;">
                            <div class="axis-arrow-head" style="border-left-color: #ff4444;"></div>
                        </div>
                    </div>
                    <div class="axis-label" id="labelX" style="color: #ff4444;">X</div>
                    
                    <!-- Y axis (green) -->
                    <div class="axis-arrow" id="axisY">
                        <div class="axis-arrow-line" style="background: #44ff44;">
                            <div class="axis-arrow-head" style="border-left-color: #44ff44;"></div>
                        </div>
                    </div>
                    <div class="axis-label" id="labelY" style="color: #44ff44;">Y</div>
                    
                    <!-- Z axis (blue) -->
                    <div class="axis-arrow" id="axisZ">
                        <div class="axis-arrow-line" style="background: #4444ff;">
                            <div class="axis-arrow-head" style="border-left-color: #4444ff;"></div>
                        </div>
                    </div>
                    <div class="axis-label" id="labelZ" style="color: #4444ff;">Z</div>
                    
                    <!-- Center dot -->
                    <div style="position: absolute; left: 47px; top: 47px; width: 6px; height: 6px; background: #888; border-radius: 50%;"></div>
                </div>
            </div>
            
            <div class="bottom-panel">
                <div class="level">
                    <div class="level-left">
                        <div class="level-item">
                            <strong>Frame: </strong>
                            <input class="input is-small ml-2" style="width: 70px;" type="number" id="currentFrameInput" min="1" value="1">
                            <strong class="ml-2">/ <span id="totalFramesDisplay">1</span></strong>
                        </div>
                        <div class="level-item ml-4">
                            <strong>Cursor: </strong>
                            <span class="ml-2" style="color: #667eea; font-family: monospace;" id="cursorPositionDisplay">X:0 Y:0 Z:0</span>
                            <span class="ml-3" style="color: #8b8b9e; font-size: 0.85rem;" id="viewPlaneIndicator">View: Front</span>
                            <span class="ml-3" style="font-size: 0.85rem;" id="onionSkinIndicator">
                                <span style="color: #8b8b9e;">Onion:</span> 
                                <span style="color: #8b8b9e;" id="onionSkinStatus">OFF</span>
                                <span style="color: #4444ff; opacity: 0;" id="onionSkinPrev">(‚Üê blue)</span>
                                <span style="color: #ff4444; opacity: 0;" id="onionSkinNext">(red ‚Üí)</span>
                            </span>
                            <span class="ml-3" style="color: #44ff44; font-size: 0.85rem;" id="boundingBoxIndicator">Grid: ON</span>
                        </div>
                    </div>
                    <div class="level-right">
                        <div class="level-item">
                            <div class="buttons">
                                <button class="button is-small is-success" id="playBtn">‚ñ∂</button>
                                <button class="button is-small is-warning" id="pauseBtn">‚è∏</button>
                            </div>
                        </div>
                    </div>
                </div>
                <input class="" id="frameSlider" type="range" min="0" max="0" value="0">
                
                <div class="buttons is-centered mt-3">
                    <button class="button is-small" id="prevFrame">‚Üê Previous</button>
                    <button class="button is-small" id="nextFrame">Next ‚Üí</button>
                    <button class="button is-small is-success" id="addFrame">+ Add Empty</button>
                    <button class="button is-small is-info" id="duplicateFrame">Duplicate Frame</button>
                    <button class="button is-small is-danger" id="deleteFrame">Delete Frame</button>
                </div>
                
                <div class="help has-text-centered mt-2" style="color: #8b8b9e; font-size: 0.85rem;">
                    üí° <strong>Interactive Controls:</strong> Point & click to place | Right-click to remove | 
                    WASD/QE: Move cursor | Drag: Rotate | Shift+Drag: Pan | Wheel: Zoom | R: Reset pan | O: Toggle onion skin | G: Toggle grid
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { createHologlyphHeader, HSBAUtil, HologlyphPlayer, parseHologlyphHeader, compressGlyfFile, getCompressionStats, decompressGlyfFile } from './hologlyph.js';

        // Panel toggling
        document.querySelectorAll('.tool-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const panelId = btn.dataset.panel + '-panel';
                const panel = document.getElementById(panelId);
                
                // Toggle panel
                if (panel.classList.contains('active')) {
                    panel.classList.remove('active');
                    btn.classList.remove('active');
                } else {
                    panel.classList.add('active');
                    btn.classList.add('active');
                }
                
                // Save panel state after toggling
                savePanelState();
            });
        });

        // Panel close buttons
        document.querySelectorAll('.panel-close').forEach(btn => {
            btn.addEventListener('click', () => {
                const panelId = btn.dataset.panel + '-panel';
                const panel = document.getElementById(panelId);
                const toolButton = document.querySelector(`.tool-button[data-panel="${btn.dataset.panel}"]`);
                
                panel.classList.remove('active');
                toolButton.classList.remove('active');
                
                // Save panel state after closing
                savePanelState();
            });
        });

        // Panel resizing constants
        const MIN_PANEL_HEIGHT = 200;
        const DEFAULT_PANEL_HEIGHTS = {
            'project': 400,
            'shape': 450,
            'color': 350,
            'voxel': 450,
            'camera': 250,
            'stats': 250,
            'file': 200
        };
        
        document.querySelectorAll('.panel-resize-handle').forEach(handle => {
            let isResizing = false;
            let currentPanel = null;
            let startY = 0;
            let startHeight = 0;
            
            handle.addEventListener('mousedown', (e) => {
                const panelId = handle.dataset.panel + '-panel';
                currentPanel = document.getElementById(panelId);
                
                if (!currentPanel.classList.contains('active')) return;
                
                isResizing = true;
                startY = e.clientY;
                startHeight = currentPanel.offsetHeight;
                
                e.preventDefault();
                document.body.style.cursor = 'ns-resize';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing || !currentPanel) return;
                
                const deltaY = e.clientY - startY;
                const newHeight = Math.max(MIN_PANEL_HEIGHT, startHeight + deltaY);
                currentPanel.style.height = newHeight + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    currentPanel = null;
                    document.body.style.cursor = '';
                    
                    // Save panel state after resizing
                    savePanelState();
                }
            });
        });

        // Editor state
        let editorState = {
            width: 16,
            height: 16,
            depth: 16,
            frameCount: 1,
            frameDurationMs: 100,
            loop: true,
            currentFrame: 0,
            voxelData: null,
            projectName: 'Untitled',
            lastSaved: null,
            // Interactive cursor state
            cursorPosition: { x: 0, y: 0, z: 0 },
            cursorVisible: true,
            placementMode: 'add', // 'add' or 'remove'
            // Camera state
            cameraPan: { x: 0, y: 0 }, // Pan offset in pixels
            // Onion skinning
            onionSkinEnabled: false,
            onionSkinFrames: 3, // Number of frames to show in each direction
            // Bounding box grid
            boundingBoxVisible: true, // Show bounding box grid by default in editor
            // Trace image
            traceImage: null, // Image object for tracing
            traceImageOpacity: 50, // Opacity percentage (0-100)
            traceImageScale: 100, // Scale percentage (25-200)
            traceImagePosX: 0, // X offset in pixels
            traceImagePosY: 0, // Y offset in pixels
        };

        let player = null;
        let autoSaveInterval = null;

        // LocalStorage keys
        const STORAGE_KEYS = {
            PROJECTS: 'hologlyph_projects',
            CURRENT_PROJECT: 'hologlyph_current_project',
            SETTINGS: 'hologlyph_settings',
            PANEL_STATE: 'hologlyph_panel_state'
        };

        // Load user settings
        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS) || '{}');
            return {
                autoSaveEnabled: settings.autoSaveEnabled !== false
            };
        }

        // Save user settings
        function saveSettings() {
            const settings = {
                autoSaveEnabled: document.getElementById('autoSaveEnabled').checked
            };
            localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            setupAutoSave();
        }
        
        // Save panel state (open/closed, heights)
        function savePanelState() {
            const panelState = {};
            document.querySelectorAll('.panel').forEach(panel => {
                const panelName = panel.id.replace('-panel', '');
                panelState[panelName] = {
                    open: panel.classList.contains('active'),
                    height: parseInt(panel.style.height) || 0
                };
            });
            localStorage.setItem(STORAGE_KEYS.PANEL_STATE, JSON.stringify(panelState));
        }
        
        // Load panel state
        function loadPanelState() {
            const panelState = JSON.parse(localStorage.getItem(STORAGE_KEYS.PANEL_STATE) || '{}');
            
            Object.keys(panelState).forEach(panelName => {
                const panel = document.getElementById(panelName + '-panel');
                const toolButton = document.querySelector(`.tool-button[data-panel="${panelName}"]`);
                const state = panelState[panelName];
                
                if (panel && toolButton && state) {
                    // Restore open/closed state
                    if (state.open) {
                        panel.classList.add('active');
                        toolButton.classList.add('active');
                    } else {
                        panel.classList.remove('active');
                        toolButton.classList.remove('active');
                    }
                    
                    // Restore height
                    if (state.height > 0) {
                        panel.style.height = state.height + 'px';
                    }
                }
            });
        }

        // Get all saved projects
        function getSavedProjects() {
            return JSON.parse(localStorage.getItem(STORAGE_KEYS.PROJECTS) || '{}');
        }

        // Save project to localStorage
        function saveProject(projectName = null) {
            if (!projectName) {
                projectName = document.getElementById('projectName').value || 'Untitled';
            }

            const projects = getSavedProjects();
            // Convert trace image to data URL for storage
            let traceImageDataUrl = null;
            if (editorState.traceImage) {
                const canvas = document.createElement('canvas');
                canvas.width = editorState.traceImage.width;
                canvas.height = editorState.traceImage.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(editorState.traceImage, 0, 0);
                traceImageDataUrl = canvas.toDataURL();
            }
            
            const projectData = {
                name: projectName,
                width: editorState.width,
                height: editorState.height,
                depth: editorState.depth,
                frameCount: editorState.frameCount,
                frameDurationMs: editorState.frameDurationMs,
                loop: editorState.loop,
                currentFrame: editorState.currentFrame,
                voxelData: editorState.voxelData,
                traceImageDataUrl: traceImageDataUrl,
                traceImageOpacity: editorState.traceImageOpacity,
                traceImageScale: editorState.traceImageScale,
                traceImagePosX: editorState.traceImagePosX,
                traceImagePosY: editorState.traceImagePosY,
                lastSaved: new Date().toISOString()
            };

            projects[projectName] = projectData;
            localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(projects));
            localStorage.setItem(STORAGE_KEYS.CURRENT_PROJECT, projectName);

            editorState.projectName = projectName;
            editorState.lastSaved = projectData.lastSaved;
            
            updateLastSaveTime();
            updateSavedProjectsList();
            
            return true;
        }

        // Load project from localStorage
        function loadProject(projectName) {
            const projects = getSavedProjects();
            const projectData = projects[projectName];

            if (!projectData) {
                alert('Project not found');
                return false;
            }

            // Restore editor state
            editorState.width = projectData.width;
            editorState.height = projectData.height;
            editorState.depth = projectData.depth;
            editorState.frameCount = projectData.frameCount;
            editorState.frameDurationMs = projectData.frameDurationMs;
            editorState.loop = projectData.loop;
            editorState.currentFrame = projectData.currentFrame;
            editorState.voxelData = projectData.voxelData;
            editorState.projectName = projectData.name;
            editorState.lastSaved = projectData.lastSaved;
            
            // Restore trace image if available
            if (projectData.traceImageDataUrl) {
                const img = new Image();
                img.onload = function() {
                    editorState.traceImage = img;
                    editorState.traceImageOpacity = projectData.traceImageOpacity || 50;
                    editorState.traceImageScale = projectData.traceImageScale || 100;
                    editorState.traceImagePosX = projectData.traceImagePosX || 0;
                    editorState.traceImagePosY = projectData.traceImagePosY || 0;
                    
                    // Update UI controls
                    document.getElementById('imageControls').style.display = 'block';
                    document.getElementById('imagePreviewContainer').style.display = 'block';
                    document.getElementById('imageOpacity').value = editorState.traceImageOpacity;
                    document.getElementById('imageOpacityValue').textContent = editorState.traceImageOpacity;
                    document.getElementById('imageScale').value = editorState.traceImageScale;
                    document.getElementById('imageScaleValue').textContent = editorState.traceImageScale;
                    document.getElementById('imagePosX').value = editorState.traceImagePosX;
                    document.getElementById('imagePosXValue').textContent = editorState.traceImagePosX;
                    document.getElementById('imagePosY').value = editorState.traceImagePosY;
                    document.getElementById('imagePosYValue').textContent = editorState.traceImagePosY;
                    
                    // Update preview thumbnail
                    updateImagePreview(img);
                    
                    renderTraceImage();
                };
                img.src = projectData.traceImageDataUrl;
            } else {
                editorState.traceImage = null;
                document.getElementById('imageControls').style.display = 'none';
            }

            // Update UI
            document.getElementById('gridWidth').value = projectData.width;
            document.getElementById('gridHeight').value = projectData.height;
            document.getElementById('gridDepth').value = projectData.depth;
            document.getElementById('frameCount').value = projectData.frameCount;
            document.getElementById('frameDuration').value = projectData.frameDurationMs;
            document.getElementById('loopAnimation').checked = projectData.loop;
            document.getElementById('projectName').value = projectData.name;

            localStorage.setItem(STORAGE_KEYS.CURRENT_PROJECT, projectName);

            updateFrameUI();
            updatePreview();
            updateLastSaveTime();

            return true;
        }

        // Delete project from localStorage
        function deleteProject(projectName) {
            if (!confirm(`Delete project "${projectName}"?`)) return;

            const projects = getSavedProjects();
            delete projects[projectName];
            localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(projects));

            if (localStorage.getItem(STORAGE_KEYS.CURRENT_PROJECT) === projectName) {
                localStorage.removeItem(STORAGE_KEYS.CURRENT_PROJECT);
            }

            updateSavedProjectsList();
        }

        // Update saved projects list UI
        function updateSavedProjectsList() {
            const projects = getSavedProjects();
            const container = document.getElementById('savedProjectsList');
            const projectNames = Object.keys(projects);

            if (projectNames.length === 0) {
                container.innerHTML = '<p class="help">No saved projects</p>';
                return;
            }

            container.innerHTML = projectNames.map(name => {
                const project = projects[name];
                const date = new Date(project.lastSaved);
                const dateStr = date.toLocaleString();
                const isCurrent = name === editorState.projectName;

                return `
                    <div class="box" style="background: ${isCurrent ? '#1a1a2e' : '#0f0f1e'}; padding: 0.75rem; margin-bottom: 0.5rem; border: ${isCurrent ? '1px solid #667eea' : '1px solid #2a2a3e'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <strong style="color: ${isCurrent ? '#667eea' : '#fff'};">${name}</strong>
                                <br>
                                <small style="color: #8b8b9e;">${dateStr}</small>
                                <br>
                                <small style="color: #8b8b9e;">${project.width}√ó${project.height}√ó${project.depth}, ${project.frameCount} frames</small>
                            </div>
                            <div>
                                <button class="button is-small is-info" onclick="loadProjectByName('${name}')">Load</button>
                                <button class="button is-small is-danger ml-1" onclick="deleteProjectByName('${name}')">‚úï</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update last save time display
        function updateLastSaveTime() {
            const timeSpan = document.getElementById('lastSaveTime');
            if (editorState.lastSaved) {
                const date = new Date(editorState.lastSaved);
                timeSpan.textContent = date.toLocaleString();
            } else {
                timeSpan.textContent = 'Never';
            }
        }

        // Debounced auto-save - saves after a delay to batch rapid changes
        let autoSaveTimeout = null;
        const AUTO_SAVE_DEBOUNCE_MS = 500; // Wait half second after last change
        
        function triggerAutoSave() {
            const enabled = document.getElementById('autoSaveEnabled').checked;
            if (!enabled) return;
            
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // Set new timeout
            autoSaveTimeout = setTimeout(() => {
                saveProject();
                console.log('Auto-saved project');
                autoSaveTimeout = null;
            }, AUTO_SAVE_DEBOUNCE_MS);
        }
        
        // Setup auto-save (now just for UI, actual saves happen on changes)
        function setupAutoSave() {
            // No interval needed - saves happen on changes
            // This function now just updates the UI
            const enabled = document.getElementById('autoSaveEnabled').checked;
            console.log('Auto-save:', enabled ? 'enabled (saves on changes)' : 'disabled');
        }

        // Global functions for onclick handlers
        window.loadProjectByName = (name) => loadProject(name);
        window.deleteProjectByName = (name) => deleteProject(name);

        // Try to load last project on startup
        function loadLastProject() {
            const lastProjectName = localStorage.getItem(STORAGE_KEYS.CURRENT_PROJECT);
            if (lastProjectName) {
                const projects = getSavedProjects();
                if (projects[lastProjectName]) {
                    loadProject(lastProjectName);
                    return true;
                }
            }
            return false;
        }

        // Initialize editor
        function initEditor() {
            const width = parseInt(document.getElementById('gridWidth').value);
            const height = parseInt(document.getElementById('gridHeight').value);
            const depth = parseInt(document.getElementById('gridDepth').value);
            const frameCount = parseInt(document.getElementById('frameCount').value);
            const frameDurationMs = parseInt(document.getElementById('frameDuration').value);
            const loop = document.getElementById('loopAnimation').checked;

            editorState.width = width;
            editorState.height = height;
            editorState.depth = depth;
            editorState.frameCount = frameCount;
            editorState.frameDurationMs = frameDurationMs;
            editorState.loop = loop;
            editorState.currentFrame = 0;
            editorState.projectName = 'Untitled';
            editorState.lastSaved = null;

            // Initialize voxel data array
            editorState.voxelData = [];
            for (let f = 0; f < frameCount; f++) {
                const frame = [];
                for (let z = 0; z < depth; z++) {
                    const plane = [];
                    for (let y = 0; y < height; y++) {
                        const row = [];
                        for (let x = 0; x < width; x++) {
                            row.push({ h: 0, s: 0, b: 0, a: 0 });
                        }
                        plane.push(row);
                    }
                    frame.push(plane);
                }
                editorState.voxelData.push(frame);
            }

            updateFrameUI();
            updatePreview();
        }

        // Generate hologlyph data from editor state (without cursor)
        function generateHologlyphData() {
            return generateHologlyphDataWithCursor(true); // Skip cursor highlight
        }

        // Update preview with cursor highlight
        function updatePreview(skipCursorHighlight = false) {
            const canvas = document.getElementById('previewCanvas');
            
            // Add temporary cursor highlight voxel to the data
            const data = generateHologlyphDataWithCursor(skipCursorHighlight);

            // Preserve camera rotation and zoom
            const rotX = player ? player.viewRotationX : 0.3;
            const rotY = player ? player.viewRotationY : 0.6;
            const zoom = player ? player.zoomLevel : 1.0;

            if (player) {
                player.destroy();
            }

            player = new HologlyphPlayer({
                canvas,
                data,
                autoPlay: false,
                voxelSize: 8,
                orbitalDrag: false, // We'll handle dragging ourselves to support pan
                useWebGL: true,
                showGrid: false, // Old per-voxel grid (disabled)
                showBoundingBox: editorState.boundingBoxVisible, // Toggleable bounding box grid
                initialRotationX: rotX,
                initialRotationY: rotY,
                traceImage: editorState.traceImage || null,
                traceImageOpacity: (editorState.traceImageOpacity || 50) / 100,
                traceImageScale: (editorState.traceImageScale || 100) / 100,
                traceImagePosX: editorState.traceImagePosX || 0,
                traceImagePosY: editorState.traceImagePosY || 0
            });

            player.zoomLevel = zoom;
            player.currentFrame = editorState.currentFrame;
            player.render();
            
            // Update axis indicator overlay
            drawAxisIndicator();
            
            // Re-render trace image (in case canvas was cleared)
            renderTraceImage();
        }
        
        // Generate hologlyph data with optional cursor highlight and onion skinning
        function generateHologlyphDataWithCursor(skipCursor = false) {
            const { header, totalSize } = createHologlyphHeader({
                width: editorState.width,
                height: editorState.height,
                depth: editorState.depth,
                frameCount: editorState.frameCount,
                frameDurationMs: editorState.frameDurationMs,
                loop: editorState.loop,
                loopStartFrame: 0,
                bytesPerVoxel: 4,
            });

            const buffer = new Uint8Array(totalSize);

            buffer.set(header, 0);

            let offset = header.length;
            for (let f = 0; f < editorState.frameCount; f++) {
                for (let z = 0; z < editorState.depth; z++) {
                    for (let y = 0; y < editorState.height; y++) {
                        for (let x = 0; x < editorState.width; x++) {
                            let voxel = editorState.voxelData[f][z][y][x];
                            
                            // Apply onion skinning for current frame display
                            if (editorState.onionSkinEnabled && f === editorState.currentFrame) {
                                voxel = applyOnionSkin(x, y, z, voxel);
                            }
                            
                            // Add cursor highlight for current frame at cursor position
                            if (!skipCursor && 
                                f === editorState.currentFrame &&
                                x === editorState.cursorPosition.x &&
                                y === editorState.cursorPosition.y &&
                                z === editorState.cursorPosition.z &&
                                editorState.cursorVisible) {
                                
                                // If voxel is empty, show cursor as semi-transparent highlight
                                if (voxel.a === 0 || voxel.b === 0) {
                                    voxel = { h: 170, s: 90, b: 80, a: 60 }; // Brighter purple highlight
                                } else {
                                    // If voxel exists, add a bright outline effect
                                    voxel = { 
                                        h: voxel.h, 
                                        s: Math.max(0, voxel.s - 30), 
                                        b: Math.min(100, voxel.b + 40), 
                                        a: Math.min(100, voxel.a + 10)
                                    };
                                }
                            }
                            
                            const pixel = HSBAUtil.encodePixel(voxel);
                            buffer.set(pixel, offset);
                            offset += 4;
                        }
                    }
                }
            }

            return buffer;
        }
        
        // Apply onion skinning effect - blend nearby frames as ghosted silhouettes
        function applyOnionSkin(x, y, z, currentVoxel) {
            const current = editorState.currentFrame;
            const maxDistance = editorState.onionSkinFrames;
            
            // Start with current frame voxel
            let resultVoxel = { ...currentVoxel };
            
            // If current voxel is empty, show ghosts from nearby frames
            if (currentVoxel.a === 0 || currentVoxel.b === 0) {
                let foundGhost = false;
                
                // Check previous frames (shown in blue tint) - closest to farthest
                for (let distance = 1; distance <= maxDistance; distance++) {
                    const prevFrame = current - distance;
                    if (prevFrame >= 0 && !foundGhost) {
                        const prevVoxel = editorState.voxelData[prevFrame][z][y][x];
                        if (prevVoxel.a > 0 && prevVoxel.b > 0) {
                            // Show as blue ghost with opacity falloff (linear)
                            const opacityFactor = (maxDistance - distance + 1) / (maxDistance + 1);
                            const opacity = Math.floor(opacityFactor * ONION_SKIN_MAX_OPACITY);
                            resultVoxel = {
                                h: ONION_SKIN_HUE_PREV,
                                s: ONION_SKIN_SATURATION,
                                b: ONION_SKIN_BRIGHTNESS,
                                a: opacity
                            };
                            foundGhost = true;
                        }
                    }
                }
                
                // Check next frames (shown in red tint) - closest to farthest
                for (let distance = 1; distance <= maxDistance; distance++) {
                    const nextFrame = current + distance;
                    if (nextFrame < editorState.frameCount && !foundGhost) {
                        const nextVoxel = editorState.voxelData[nextFrame][z][y][x];
                        if (nextVoxel.a > 0 && nextVoxel.b > 0) {
                            // Show as red ghost with opacity falloff (linear)
                            const opacityFactor = (maxDistance - distance + 1) / (maxDistance + 1);
                            const opacity = Math.floor(opacityFactor * ONION_SKIN_MAX_OPACITY);
                            resultVoxel = {
                                h: ONION_SKIN_HUE_NEXT,
                                s: ONION_SKIN_SATURATION,
                                b: ONION_SKIN_BRIGHTNESS,
                                a: opacity
                            };
                            foundGhost = true;
                        }
                    }
                }
            }
            
            return resultVoxel;
        }
        
        // ========================================
        // INTERACTIVE EDITOR FEATURES
        // ========================================
        // 
        // This section adds Minecraft-like interactive voxel placement:
        // - Crosshair-based selection (center of screen, like FPS games)
        // - Click to place voxels at crosshair position
        // - Right-click to remove voxels
        // - Keyboard controls: WASD (X/Y), Q/E (Z), Space (place), Delete (remove)
        // - Visual cursor shown as semi-transparent voxel in the grid
        // - 3D axis indicator shows orientation
        //
        // Note: All editor-only features (Layer 4), no player modifications
        // ========================================
        
        // Constants for interactive editing
        const VOXEL_SIZE = 8; // Must match player voxelSize
        const AXIS_INDICATOR_SIZE = 80; // Size of axis indicator widget
        const AXIS_LENGTH = 30; // Length of axis arrows
        const AXIS_LINE_THICKNESS = 3; // Thickness of axis lines (pixels)
        const AXIS_OFFSET = 12; // Offset from center to prevent overlap (pixels)
        const AXIS_LABEL_OFFSET = 10; // Distance of label from arrow end
        const ONION_SKIN_HUE_PREV = 170; // Blue hue for previous frames
        const ONION_SKIN_HUE_NEXT = 0; // Red hue for future frames
        const ONION_SKIN_SATURATION = 70; // Saturation for ghost frames
        const ONION_SKIN_BRIGHTNESS = 50; // Brightness for ghost frames
        const ONION_SKIN_MAX_OPACITY = 40; // Max opacity for closest ghost frame
        
        // Throttle preview updates for performance
        let previewUpdateThrottle = null;
        function throttledPreviewUpdate() {
            if (previewUpdateThrottle) return;
            
            previewUpdateThrottle = setTimeout(() => {
                updatePreview();
                previewUpdateThrottle = null;
            }, 50); // Update at most 20 times per second
        }
        
        // Update 3D axis indicator (HTML overlay)
        function drawAxisIndicator() {
            if (!player) return;
            
            // Get camera rotation
            const rotX = player.viewRotationX || 0.3;
            const rotY = player.viewRotationY || 0.6;
            
            const AXIS_CENTER = 50; // Center position in widget (pixels)
            
            // Define axis vectors
            const axes = [
                { id: 'axisX', labelId: 'labelX', dir: [1, 0, 0] },
                { id: 'axisY', labelId: 'labelY', dir: [0, 1, 0] },
                { id: 'axisZ', labelId: 'labelZ', dir: [0, 0, 1] }
            ];
            
            // Transform each axis
            axes.forEach(axis => {
                const [x, y, z] = axis.dir;
                
                // Apply Y rotation (horizontal)
                const cosY = Math.cos(rotY);
                const sinY = Math.sin(rotY);
                const rx = x * cosY - z * sinY;
                const rz = x * sinY + z * cosY;
                
                // Apply X rotation (vertical)
                const cosX = Math.cos(rotX);
                const sinX = Math.sin(rotX);
                const ry = y * cosX - rz * sinX;
                const finalZ = y * sinX + rz * cosX;
                
                // Calculate angle for 2D rotation
                const angle = Math.atan2(-ry, rx) * (180 / Math.PI);
                const length = Math.sqrt(rx * rx + ry * ry) * AXIS_LENGTH;
                
                // Normalize the 2D direction vector
                const dirLength = Math.sqrt(rx * rx + ry * ry);
                const dirX = dirLength > 0 ? rx / dirLength : 0;
                const dirY = dirLength > 0 ? ry / dirLength : 0;
                
                // Calculate offset along arrow direction to prevent overlap
                const offsetX = dirX * AXIS_OFFSET;
                const offsetY = -dirY * AXIS_OFFSET; // Negative because Y is inverted in screen space
                
                // Update arrow element
                const arrowEl = document.getElementById(axis.id);
                if (arrowEl) {
                    arrowEl.style.left = `${AXIS_CENTER + offsetX}px`;
                    arrowEl.style.top = `${AXIS_CENTER + offsetY}px`;
                    arrowEl.style.transform = `rotate(${angle}deg)`;
                    const lineEl = arrowEl.querySelector('.axis-arrow-line');
                    if (lineEl) {
                        lineEl.style.width = `${length}px`;
                        lineEl.style.height = `${AXIS_LINE_THICKNESS}px`;
                    }
                    arrowEl.style.opacity = finalZ > 0 ? '1' : '0.3';
                    arrowEl.style.zIndex = finalZ > 0 ? '10' : '5';
                }
                
                // Update label position
                const labelEl = document.getElementById(axis.labelId);
                if (labelEl) {
                    const labelX = rx * AXIS_LENGTH + offsetX + AXIS_LABEL_OFFSET;
                    const labelY = -ry * AXIS_LENGTH + offsetY + 5;
                    labelEl.style.left = `${AXIS_CENTER + labelX}px`;
                    labelEl.style.top = `${AXIS_CENTER + labelY}px`;
                    labelEl.style.opacity = finalZ > 0 ? '1' : '0.3';
                    labelEl.style.zIndex = finalZ > 0 ? '10' : '5';
                }
            });
        }
        
        // Matrix multiplication helper
        function multiplyMatrixVector(matrix, vector) {
            const result = [0, 0, 0, 0];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i] += matrix[i * 4 + j] * vector[j];
                }
            }
            return result;
        }
        
        // Matrix inversion helper (for 4x4 matrices)
        function invertMatrix(matrix) {
            const inv = new Float32Array(16);
            const m = matrix;
            
            inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] + m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
            inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] - m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
            inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] + m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
            inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] - m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
            
            inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] - m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
            inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] + m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
            inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] - m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
            inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] + m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
            
            inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] + m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
            inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] - m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
            inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] + m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
            inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] - m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
            
            inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] - m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
            inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] + m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
            inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] - m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
            inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] + m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];
            
            let det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
            if (det === 0) return null;
            det = 1.0 / det;
            
            for (let i = 0; i < 16; i++) {
                inv[i] *= det;
            }
            
            return inv;
        }
        
        // Create orthographic projection matrix (matching player's implementation)
        function createOrthographicMatrix(left, right, bottom, top, near, far) {
            const lr = 1 / (left - right);
            const bt = 1 / (bottom - top);
            const nf = 1 / (near - far);
            
            return new Float32Array([
                -2 * lr, 0, 0, 0,
                0, -2 * bt, 0, 0,
                0, 0, 2 * nf, 0,
                (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1
            ]);
        }
        
        // Create view matrix (matching player's implementation)
        function createViewMatrix(rotX, rotY, distance) {
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            
            const cx = distance * cosX * sinY;
            const cy = distance * sinX;
            const cz = distance * cosX * cosY;
            
            // Look at origin
            const fx = -cx;
            const fy = -cy;
            const fz = -cz;
            const len = Math.sqrt(fx * fx + fy * fy + fz * fz);
            const fnx = fx / len;
            const fny = fy / len;
            const fnz = fz / len;
            
            const upX = 0, upY = 1, upZ = 0;
            let rx = upY * fnz - upZ * fny;
            let ry = upZ * fnx - upX * fnz;
            let rz = upX * fny - upY * fnx;
            const rlen = Math.sqrt(rx * rx + ry * ry + rz * rz);
            rx /= rlen; ry /= rlen; rz /= rlen;
            
            const ux = fny * rz - fnz * ry;
            const uy = fnz * rx - fnx * rz;
            const uz = fnx * ry - fny * rx;
            
            return new Float32Array([
                rx, ux, fnx, 0,
                ry, uy, fny, 0,
                rz, uz, fnz, 0,
                -(rx * cx + ry * cy + rz * cz),
                -(ux * cx + uy * cy + uz * cz),
                -(fnx * cx + fny * cy + fnz * cz),
                1
            ]);
        }
        
        // Unproject NDC to world space for orthographic projection
        function unprojectOrthographic(ndcX, ndcY, viewMatrix, left, right, bottom, top, near, far) {
            // Invert view matrix to transform from view space to world space
            const viewInv = invertMatrix(viewMatrix);
            if (!viewInv) return null;
            
            // For orthographic, unproject NDC directly to view space
            // NDC to view space: x = (ndcX * (right - left) + (right + left)) / 2
            const viewX = (ndcX * (right - left) + (right + left)) / 2;
            const viewY = (ndcY * (top - bottom) + (top + bottom)) / 2;
            
            // Create two points in view space (near and far planes)
            // Note: in view space, camera looks down -Z, so near is -near, far is -far
            const nearView = [viewX, viewY, -near, 1];
            const farView = [viewX, viewY, -far, 1];
            
            // Transform to world space
            const nearWorld = multiplyMatrixVector(viewInv, nearView);
            const farWorld = multiplyMatrixVector(viewInv, farView);
            
            // Normalize homogeneous coordinates
            if (Math.abs(nearWorld[3]) > 0.0001) {
                nearWorld[0] /= nearWorld[3];
                nearWorld[1] /= nearWorld[3];
                nearWorld[2] /= nearWorld[3];
            }
            if (Math.abs(farWorld[3]) > 0.0001) {
                farWorld[0] /= farWorld[3];
                farWorld[1] /= farWorld[3];
                farWorld[2] /= farWorld[3];
            }
            
            // Ray direction is from near to far
            const dirX = farWorld[0] - nearWorld[0];
            const dirY = farWorld[1] - nearWorld[1];
            const dirZ = farWorld[2] - nearWorld[2];
            const dirLen = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            
            if (dirLen < 0.0001) return null;
            
            return {
                origin: [nearWorld[0], nearWorld[1], nearWorld[2]],
                direction: [dirX / dirLen, dirY / dirLen, dirZ / dirLen]
            };
        }
        
        // Ray-AABB intersection (for voxel cubes)
        function rayIntersectAABB(rayOrigin, rayDir, boxMin, boxMax) {
            const invDir = [
                1 / rayDir[0],
                1 / rayDir[1],
                1 / rayDir[2]
            ];
            
            const t1 = (boxMin[0] - rayOrigin[0]) * invDir[0];
            const t2 = (boxMax[0] - rayOrigin[0]) * invDir[0];
            const t3 = (boxMin[1] - rayOrigin[1]) * invDir[1];
            const t4 = (boxMax[1] - rayOrigin[1]) * invDir[1];
            const t5 = (boxMin[2] - rayOrigin[2]) * invDir[2];
            const t6 = (boxMax[2] - rayOrigin[2]) * invDir[2];
            
            const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
            const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
            
            if (tmax < 0 || tmin > tmax) return null;
            
            const t = tmin >= 0 ? tmin : tmax;
            return t;
        }
        
        // Get voxel at mouse position using improved projection
        function getVoxelFromMouse(mouseX, mouseY) {
            if (!player || !player.useWebGL) return editorState.cursorPosition;
            
            const canvas = player.canvas;
            const rect = canvas.getBoundingClientRect();
            
            // Convert mouse to normalized device coordinates (-1 to 1)
            const normX = ((mouseX - rect.left) / rect.width) * 2 - 1;
            const normY = -(((mouseY - rect.top) / rect.height) * 2 - 1);
            
            // Get camera parameters
            const rotX = player.viewRotationX || 0.3;
            const rotY = player.viewRotationY || 0.6;
            const zoom = player.zoomLevel || 1.0;
            
            // Calculate camera forward direction (where camera is looking)
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            
            // Forward vector (camera looks in this direction)
            const forwardX = -cosX * sinY;
            const forwardY = -sinX;
            const forwardZ = -cosX * cosY;
            
            // Right vector (camera's right side)
            const rightX = cosY;
            const rightY = 0;
            const rightZ = -sinY;
            
            // Up vector (camera's up)
            const upX = sinX * sinY;
            const upY = cosX;
            const upZ = sinX * cosY;
            
            // Grid dimensions
            const halfW = editorState.width / 2;
            const halfH = editorState.height / 2;
            const halfD = editorState.depth / 2;
            
            // Calculate projection size (matching player's orthographic projection)
            const aspect = canvas.width / canvas.height;
            const size = Math.max(editorState.width, editorState.height, editorState.depth) * 1.2 / zoom;
            
            // Project mouse position onto a plane perpendicular to camera forward
            // The plane is at the center of the grid
            const planePoint = [0, 0, 0]; // Center of grid
            
            // Calculate point on plane from mouse position
            const worldX = planePoint[0] + normX * size * aspect * rightX + normY * size * upX;
            const worldY = planePoint[1] + normX * size * aspect * rightY + normY * size * upY;
            const worldZ = planePoint[2] + normX * size * aspect * rightZ + normY * size * upZ;
            
            // Convert world position to voxel coordinates
            let vx = Math.floor(worldX + halfW);
            let vy = Math.floor(worldY + halfH);
            let vz = Math.floor(worldZ + halfD);
            
            // Determine which axis to lock based on viewing angle
            const rotYNorm = ((rotY % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            let viewPlane = 'front';
            
            // Lock the axis that's most perpendicular to view
            if (rotYNorm >= Math.PI / 4 && rotYNorm < 3 * Math.PI / 4) {
                // Right view - lock X
                viewPlane = 'right';
                vx = editorState.cursorPosition.x;
            } else if (rotYNorm >= 3 * Math.PI / 4 && rotYNorm < 5 * Math.PI / 4) {
                // Back view - lock Z
                viewPlane = 'back';
                vz = editorState.cursorPosition.z;
            } else if (rotYNorm >= 5 * Math.PI / 4 && rotYNorm < 7 * Math.PI / 4) {
                // Left view - lock X
                viewPlane = 'left';
                vx = editorState.cursorPosition.x;
            } else {
                // Front view - lock Z
                viewPlane = 'front';
                vz = editorState.cursorPosition.z;
            }
            
            // Clamp to grid bounds
            vx = Math.max(0, Math.min(editorState.width - 1, vx));
            vy = Math.max(0, Math.min(editorState.height - 1, vy));
            vz = Math.max(0, Math.min(editorState.depth - 1, vz));
            
            updateViewPlaneIndicator(viewPlane);
            
            return { x: vx, y: vy, z: vz };
        }
        
        // Place voxel at cursor position
        function placeVoxelAtCursor() {
            const { x, y, z } = editorState.cursorPosition;
            const color = getCurrentColor();
            
            if (x >= 0 && x < editorState.width &&
                y >= 0 && y < editorState.height &&
                z >= 0 && z < editorState.depth) {
                editorState.voxelData[editorState.currentFrame][z][y][x] = color;
                updateStats();
                updatePreview();
                triggerAutoSave();
            }
        }
        
        // Remove voxel at cursor position
        function removeVoxelAtCursor() {
            const { x, y, z } = editorState.cursorPosition;
            
            if (x >= 0 && x < editorState.height &&
                y >= 0 && y < editorState.height &&
                z >= 0 && z < editorState.depth) {
                editorState.voxelData[editorState.currentFrame][z][y][x] = { h: 0, s: 0, b: 0, a: 0 };
                updateStats();
                updatePreview();
                triggerAutoSave();
            }
        }
        
        // Update cursor position display
        function updateCursorDisplay() {
            const display = document.getElementById('cursorPositionDisplay');
            if (display) {
                const { x, y, z } = editorState.cursorPosition;
                display.textContent = `X:${x} Y:${y} Z:${z}`;
            }
        }
        
        // Update view plane indicator
        function updateViewPlaneIndicator(plane) {
            const indicator = document.getElementById('viewPlaneIndicator');
            if (indicator) {
                const planes = {
                    'front': 'View: Front (XY plane)',
                    'right': 'View: Right (ZY plane)',
                    'back': 'View: Back (XY plane)',
                    'left': 'View: Left (ZY plane)'
                };
                indicator.textContent = planes[plane] || 'View: Unknown';
            }
        }
        
        // Move cursor with keyboard (camera-relative)
        function moveCursor(dx, dy, dz) {
            if (!player) return;
            
            // Get camera rotation (Y axis rotation - horizontal)
            const rotY = player.viewRotationY || 0.6;
            
            // Transform movement based on camera rotation
            // dx: left(-)/right(+) in camera view
            // dy: down(-)/up(+) absolute
            // dz: back(-)/forward(+) in camera view
            
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            
            // Rotate horizontal movement (dx and dz) around Y axis
            // Standard 2D rotation matrix:
            // [cos -sin] [dx]   [dx*cos - dz*sin]
            // [sin  cos] [dz] = [dx*sin + dz*cos]
            const worldDx = Math.round(dx * cosY - dz * sinY);
            const worldDy = dy; // Y movement is always absolute (up/down)
            const worldDz = Math.round(dx * sinY + dz * cosY);
            
            // Apply movement with bounds checking
            editorState.cursorPosition.x = Math.max(0, Math.min(editorState.width - 1, editorState.cursorPosition.x + worldDx));
            editorState.cursorPosition.y = Math.max(0, Math.min(editorState.height - 1, editorState.cursorPosition.y + worldDy));
            editorState.cursorPosition.z = Math.max(0, Math.min(editorState.depth - 1, editorState.cursorPosition.z + worldDz));
            
            // Update voxel editor UI
            document.getElementById('voxelX').value = editorState.cursorPosition.x;
            document.getElementById('voxelY').value = editorState.cursorPosition.y;
            document.getElementById('voxelZ').value = editorState.cursorPosition.z;
            document.getElementById('voxelXSlider').value = editorState.cursorPosition.x;
            document.getElementById('voxelYSlider').value = editorState.cursorPosition.y;
            document.getElementById('voxelZSlider').value = editorState.cursorPosition.z;
            
            updateCursorDisplay();
            throttledPreviewUpdate();
        }
        
        // Setup interactive canvas events
        function setupInteractiveCanvas() {
            const canvas = document.getElementById('previewCanvas');
            
            // Track mouse state for dragging
            let mouseDownPos = null;
            let isDragging = false;
            let isShiftHeld = false;
            let dragStartRotX = 0;
            let dragStartRotY = 0;
            let lastMouseX = null;
            let lastMouseY = null;
            const DRAG_THRESHOLD = 5; // pixels
            const ROTATION_SPEED = 0.005;
            
            // Update axis indicator when camera rotates
            let lastRotX = null;
            let lastRotY = null;
            
            function checkCameraUpdate() {
                if (!player) return;
                
                const rotX = player.viewRotationX;
                const rotY = player.viewRotationY;
                
                // Redraw axes when camera rotates
                if (lastRotX === null || lastRotY === null ||
                    Math.abs(rotX - lastRotX) > 0.001 || 
                    Math.abs(rotY - lastRotY) > 0.001) {
                    
                    lastRotX = rotX;
                    lastRotY = rotY;
                    drawAxisIndicator();
                    
                    // If we have a last mouse position, update cursor
                    if (lastMouseX !== null && lastMouseY !== null) {
                        updateCursorFromMouse(lastMouseX, lastMouseY);
                    }
                }
            }
            
            // Poll for camera rotation changes
            setInterval(checkCameraUpdate, 16); // ~60 FPS
            
            // Update cursor position from mouse
            function updateCursorFromMouse(mouseX, mouseY) {
                const voxel = getVoxelFromMouse(mouseX, mouseY);
                if (voxel.x !== editorState.cursorPosition.x ||
                    voxel.y !== editorState.cursorPosition.y ||
                    voxel.z !== editorState.cursorPosition.z) {
                    
                    editorState.cursorPosition = voxel;
                    
                    // Update voxel editor UI
                    document.getElementById('voxelX').value = voxel.x;
                    document.getElementById('voxelY').value = voxel.y;
                    document.getElementById('voxelZ').value = voxel.z;
                    document.getElementById('voxelXSlider').value = voxel.x;
                    document.getElementById('voxelYSlider').value = voxel.y;
                    document.getElementById('voxelZSlider').value = voxel.z;
                    
                    updateCursorDisplay();
                    throttledPreviewUpdate();
                }
            }
            
            canvas.addEventListener('mousedown', (e) => {
                mouseDownPos = { x: e.clientX, y: e.clientY };
                isDragging = false;
                isShiftHeld = e.shiftKey;
                
                if (player) {
                    dragStartRotX = player.viewRotationX;
                    dragStartRotY = player.viewRotationY;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                // Store mouse position for cursor updates
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Check if dragging
                if (e.buttons > 0 && mouseDownPos) {
                    const dx = e.clientX - mouseDownPos.x;
                    const dy = e.clientY - mouseDownPos.y;
                    
                    if (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD) {
                        isDragging = true;
                        
                        if (isShiftHeld) {
                            // Pan mode: translate the canvas
                            editorState.cameraPan.x += dx / 2;
                            editorState.cameraPan.y += dy / 2;
                            
                            // Apply transform to canvas
                            canvas.style.transform = `translate(${editorState.cameraPan.x}px, ${editorState.cameraPan.y}px)`;
                            
                            // Update axis indicator position too
                            const axisOverlay = document.querySelector('.axis-overlay');
                            if (axisOverlay) {
                                axisOverlay.style.transform = `translate(${editorState.cameraPan.x}px, ${editorState.cameraPan.y}px)`;
                            }
                            
                            // Reset mouse position for continuous panning
                            mouseDownPos = { x: e.clientX, y: e.clientY };
                            
                            canvas.style.cursor = 'move';
                        } else {
                            // Rotate mode: orbital rotation
                            if (player) {
                                player.viewRotationY = dragStartRotY - dx * ROTATION_SPEED;
                                player.viewRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, 
                                    dragStartRotX - dy * ROTATION_SPEED));
                                player.render();
                                drawAxisIndicator();
                            }
                            canvas.style.cursor = 'grabbing';
                        }
                    }
                } else {
                    // Not dragging - update cursor position from mouse
                    canvas.style.cursor = 'crosshair';
                    updateCursorFromMouse(e.clientX, e.clientY);
                }
            });
            
            // Click to place voxel (only if not dragging)
            canvas.addEventListener('mouseup', (e) => {
                canvas.style.cursor = 'crosshair';
                
                // Only place if this was a click (not a drag)
                if (!isDragging && mouseDownPos) {
                    if (e.button === 0) { // Left click
                        placeVoxelAtCursor();
                    }
                }
                mouseDownPos = null;
                isDragging = false;
                isShiftHeld = false;
            });
            
            // Right click to remove
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!isDragging) {
                    removeVoxelAtCursor();
                }
            });
            
            // Mouse wheel for zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (player) {
                    const zoomDelta = e.deltaY * -0.001;
                    player.zoomLevel = Math.max(0.3, Math.min(3, player.zoomLevel + zoomDelta));
                    player.render();
                    drawAxisIndicator();
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                // Don't interfere with input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const CURSOR_MOVE_STEP = 1;
                
                switch (e.key.toLowerCase()) {
                    case 'w':
                        e.preventDefault();
                        // Forward (into screen in camera view)
                        moveCursor(0, 0, CURSOR_MOVE_STEP);
                        break;
                    case 's':
                        e.preventDefault();
                        // Backward (out of screen in camera view)
                        moveCursor(0, 0, -CURSOR_MOVE_STEP);
                        break;
                    case 'a':
                        e.preventDefault();
                        // Left in camera view
                        moveCursor(-CURSOR_MOVE_STEP, 0, 0);
                        break;
                    case 'd':
                        e.preventDefault();
                        // Right in camera view
                        moveCursor(CURSOR_MOVE_STEP, 0, 0);
                        break;
                    case 'q':
                        e.preventDefault();
                        // Down (absolute)
                        moveCursor(0, -CURSOR_MOVE_STEP, 0);
                        break;
                    case 'e':
                        e.preventDefault();
                        // Up (absolute)
                        moveCursor(0, CURSOR_MOVE_STEP, 0);
                        break;
                    case ' ':
                        e.preventDefault();
                        placeVoxelAtCursor();
                        break;
                    case 'backspace':
                    case 'delete':
                        e.preventDefault();
                        removeVoxelAtCursor();
                        break;
                    case 'shift':
                        editorState.placementMode = 'remove';
                        break;
                    case 'r':
                        // Reset camera pan
                        e.preventDefault();
                        editorState.cameraPan = { x: 0, y: 0 };
                        const canvas = document.getElementById('previewCanvas');
                        if (canvas) {
                            canvas.style.transform = 'translate(0px, 0px)';
                        }
                        const axisOverlay = document.querySelector('.axis-overlay');
                        if (axisOverlay) {
                            axisOverlay.style.transform = 'translate(0px, 0px)';
                        }
                        break;
                    case 'o':
                        // Toggle onion skinning
                        e.preventDefault();
                        editorState.onionSkinEnabled = !editorState.onionSkinEnabled;
                        
                        // Update indicator
                        const statusEl = document.getElementById('onionSkinStatus');
                        const prevEl = document.getElementById('onionSkinPrev');
                        const nextEl = document.getElementById('onionSkinNext');
                        
                        if (statusEl) {
                            statusEl.textContent = editorState.onionSkinEnabled ? 'ON' : 'OFF';
                            statusEl.style.color = editorState.onionSkinEnabled ? '#44ff44' : '#8b8b9e';
                        }
                        if (prevEl) {
                            prevEl.style.opacity = editorState.onionSkinEnabled ? '1' : '0';
                        }
                        if (nextEl) {
                            nextEl.style.opacity = editorState.onionSkinEnabled ? '1' : '0';
                        }
                        
                        console.log('Onion skinning:', editorState.onionSkinEnabled ? 'ON' : 'OFF');
                        updatePreview();
                        break;
                    case 'g':
                        // Toggle bounding box grid
                        e.preventDefault();
                        editorState.boundingBoxVisible = !editorState.boundingBoxVisible;
                        
                        // Update indicator
                        const gridIndicator = document.getElementById('boundingBoxIndicator');
                        if (gridIndicator) {
                            gridIndicator.textContent = `Grid: ${editorState.boundingBoxVisible ? 'ON' : 'OFF'}`;
                            gridIndicator.style.color = editorState.boundingBoxVisible ? '#44ff44' : '#8b8b9e';
                        }
                        
                        console.log('Bounding box grid:', editorState.boundingBoxVisible ? 'ON' : 'OFF');
                        updatePreview();
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Shift') {
                    editorState.placementMode = 'add';
                }
            });
        }

        // Update frame UI
        function updateFrameUI() {
            document.getElementById('currentFrameInput').value = editorState.currentFrame + 1;
            document.getElementById('currentFrameInput').max = editorState.frameCount;
            document.getElementById('totalFramesDisplay').textContent = editorState.frameCount;
            document.getElementById('frameSlider').max = editorState.frameCount - 1;
            document.getElementById('frameSlider').value = editorState.currentFrame;
            
            // Update voxel editor bounds
            document.getElementById('voxelX').max = editorState.width - 1;
            document.getElementById('voxelY').max = editorState.height - 1;
            document.getElementById('voxelZ').max = editorState.depth - 1;
            document.getElementById('voxelXSlider').max = editorState.width - 1;
            document.getElementById('voxelYSlider').max = editorState.height - 1;
            document.getElementById('voxelZSlider').max = editorState.depth - 1;
            
            // Update shape position bounds
            document.getElementById('shapePosX').max = editorState.width - 1;
            document.getElementById('shapePosY').max = editorState.height - 1;
            document.getElementById('shapePosZ').max = editorState.depth - 1;
            
            // Set default shape position to center
            document.getElementById('shapePosX').value = Math.floor(editorState.width / 2);
            document.getElementById('shapePosY').value = Math.floor(editorState.height / 2);
            document.getElementById('shapePosZ').value = Math.floor(editorState.depth / 2);
            
            updateStats();
        }

        // Update statistics display
        function updateStats() {
            // Count non-empty voxels in current frame
            let currentFrameCount = 0;
            for (let z = 0; z < editorState.depth; z++) {
                for (let y = 0; y < editorState.height; y++) {
                    for (let x = 0; x < editorState.width; x++) {
                        const v = editorState.voxelData[editorState.currentFrame][z][y][x];
                        if (v.a > 0 && v.b > 0) currentFrameCount++;
                    }
                }
            }
            
            // Count total non-empty voxels across all frames
            let totalVoxelCount = 0;
            for (let f = 0; f < editorState.frameCount; f++) {
                for (let z = 0; z < editorState.depth; z++) {
                    for (let y = 0; y < editorState.height; y++) {
                        for (let x = 0; x < editorState.width; x++) {
                            const v = editorState.voxelData[f][z][y][x];
                            if (v.a > 0 && v.b > 0) totalVoxelCount++;
                        }
                    }
                }
            }
            
            // Calculate sizes
            const voxelsPerFrame = editorState.width * editorState.height * editorState.depth;
            const frameSize = voxelsPerFrame * 4;
            const headerSize = 28;
            const totalSize = headerSize + (frameSize * editorState.frameCount);
            
            // Format sizes
            function formatBytes(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            }
            
            // Update display
            document.getElementById('statsCurrentFrame').textContent = 
                `${editorState.currentFrame + 1} / ${editorState.frameCount}`;
            document.getElementById('statsVoxelCount').textContent = 
                `${currentFrameCount} / ${voxelsPerFrame} (${((currentFrameCount / voxelsPerFrame) * 100).toFixed(1)}%)`;
            document.getElementById('statsFrameSize').textContent = formatBytes(frameSize);
            document.getElementById('statsTotalSize').textContent = 
                `${formatBytes(totalSize)} (${totalVoxelCount} voxels set)`;
        }

        // Initialize interactive color picker canvas
        function initColorPicker() {
            const canvas = document.getElementById('colorPickerCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            function drawColorGradient() {
                // Draw hue/saturation gradient
                for (let y = 0; y < height; y++) {
                    const saturation = 100 - (y / height) * 100;
                    
                    for (let x = 0; x < width; x++) {
                        const hue = (x / width) * 360;
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, 50%)`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }

            function drawIndicator() {
                const h = parseInt(document.getElementById('colorHue').value);
                const s = parseInt(document.getElementById('colorSat').value);

                const x = (h / 255) * width;
                const y = ((100 - s) / 100) * height;

                // Draw circle indicator
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            function redrawPicker(showCrosshair = false, mouseX = 0, mouseY = 0) {
                drawColorGradient();
                
                if (showCrosshair) {
                    // Draw hover crosshair
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(mouseX - 10, mouseY);
                    ctx.lineTo(mouseX + 10, mouseY);
                    ctx.moveTo(mouseX, mouseY - 10);
                    ctx.lineTo(mouseX, mouseY + 10);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                } else {
                    // Draw current color indicator
                    drawIndicator();
                }
            }

            // Initial draw
            redrawPicker();

            // Handle clicks on color picker
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Convert position to hue and saturation
                const hue = Math.round((x / width) * 255);
                const saturation = Math.round(100 - (y / height) * 100);

                // Update inputs
                document.getElementById('colorHue').value = hue;
                document.getElementById('colorSat').value = saturation;

                updateColorPreview();
                redrawPicker();
            });

            // Show crosshair on hover
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                redrawPicker(true, x, y);
            });

            canvas.addEventListener('mouseleave', () => {
                redrawPicker();
            });

            // Store for updates
            window.updateColorPickerIndicator = () => redrawPicker();
        }

        // Update shared color preview
        function updateColorPreview() {
            const h = parseInt(document.getElementById('colorHue').value);
            const s = parseInt(document.getElementById('colorSat').value);
            const b = parseInt(document.getElementById('colorBright').value);
            const a = parseInt(document.getElementById('colorAlpha').value);

            // Convert to CSS color
            const hDeg = (h / 255) * 360;
            const preview = document.getElementById('sharedColorPreview');
            preview.style.backgroundColor = `hsla(${hDeg}, ${s}%, ${b}%, ${a / 100})`;
            
            // Update color picker indicator
            if (window.updateColorPickerIndicator) {
                window.updateColorPickerIndicator();
            }
        }

        // Get current color from shared picker
        function getCurrentColor() {
            return {
                h: parseInt(document.getElementById('colorHue').value),
                s: parseInt(document.getElementById('colorSat').value),
                b: parseInt(document.getElementById('colorBright').value),
                a: parseInt(document.getElementById('colorAlpha').value)
            };
        }

        // Set voxel
        function setVoxel() {
            const x = parseInt(document.getElementById('voxelX').value);
            const y = parseInt(document.getElementById('voxelY').value);
            const z = parseInt(document.getElementById('voxelZ').value);
            const color = getCurrentColor();

            if (x >= 0 && x < editorState.width &&
                y >= 0 && y < editorState.height &&
                z >= 0 && z < editorState.depth) {
                editorState.voxelData[editorState.currentFrame][z][y][x] = color;
                updateStats();
                updatePreview();
                triggerAutoSave();
            }
        }

        // Clear voxel
        function clearVoxel() {
            const x = parseInt(document.getElementById('voxelX').value);
            const y = parseInt(document.getElementById('voxelY').value);
            const z = parseInt(document.getElementById('voxelZ').value);

            if (x >= 0 && x < editorState.width &&
                y >= 0 && y < editorState.height &&
                z >= 0 && z < editorState.depth) {
                editorState.voxelData[editorState.currentFrame][z][y][x] = { h: 0, s: 0, b: 0, a: 0 };
                updateStats();
                updatePreview();
                triggerAutoSave();
            }
        }

        // Shape generation helpers
        function generateShape() {
            const shapeType = document.getElementById('shapeType').value;
            const width = parseInt(document.getElementById('shapeWidth').value);
            const height = parseInt(document.getElementById('shapeHeight').value);
            const depth = parseInt(document.getElementById('shapeDepth').value);
            const filled = document.getElementById('shapeFilled').checked;
            const color = getCurrentColor();

            const centerX = parseInt(document.getElementById('shapePosX').value);
            const centerY = parseInt(document.getElementById('shapePosY').value);
            const centerZ = parseInt(document.getElementById('shapePosZ').value);

            switch (shapeType) {
                case 'cube':
                    generateCube(centerX, centerY, centerZ, width, filled, color);
                    break;
                case 'box':
                    generateBox(centerX, centerY, centerZ, width, height, depth, filled, color);
                    break;
                case 'sphere':
                    generateSphere(centerX, centerY, centerZ, width, filled, color);
                    break;
                case 'pyramid':
                    generatePyramid(centerX, centerY, centerZ, width, height, filled, color);
                    break;
                case 'cone':
                    generateCone(centerX, centerY, centerZ, width, height, filled, color);
                    break;
                case 'cylinder':
                    generateCylinder(centerX, centerY, centerZ, width, height, filled, color);
                    break;
            }

            updateStats();
            updatePreview();
            triggerAutoSave();
        }

        function generateCube(cx, cy, cz, size, filled, color) {
            const halfSize = Math.floor(size / 2);
            for (let z = -halfSize; z < halfSize; z++) {
                for (let y = -halfSize; y < halfSize; y++) {
                    for (let x = -halfSize; x < halfSize; x++) {
                        if (filled || Math.abs(x) === halfSize - 1 || Math.abs(y) === halfSize - 1 || Math.abs(z) === halfSize - 1) {
                            setVoxelAt(cx + x, cy + y, cz + z, color);
                        }
                    }
                }
            }
        }

        function generateBox(cx, cy, cz, w, h, d, filled, color) {
            const halfW = Math.floor(w / 2);
            const halfH = Math.floor(h / 2);
            const halfD = Math.floor(d / 2);
            for (let z = -halfD; z < halfD; z++) {
                for (let y = -halfH; y < halfH; y++) {
                    for (let x = -halfW; x < halfW; x++) {
                        if (filled || Math.abs(x) === halfW - 1 || Math.abs(y) === halfH - 1 || Math.abs(z) === halfD - 1) {
                            setVoxelAt(cx + x, cy + y, cz + z, color);
                        }
                    }
                }
            }
        }

        function generateSphere(cx, cy, cz, radius, filled, color) {
            const r = radius / 2;
            for (let z = -radius; z <= radius; z++) {
                for (let y = -radius; y <= radius; y++) {
                    for (let x = -radius; x <= radius; x++) {
                        const dist = Math.sqrt(x * x + y * y + z * z);
                        if (filled ? dist <= r : (dist <= r && dist >= r - 1)) {
                            setVoxelAt(cx + x, cy + y, cz + z, color);
                        }
                    }
                }
            }
        }

        function generatePyramid(cx, cy, cz, baseSize, height, filled, color) {
            const halfBase = Math.floor(baseSize / 2);
            for (let y = 0; y < height; y++) {
                const levelSize = halfBase * (1 - y / height);
                for (let z = -levelSize; z <= levelSize; z++) {
                    for (let x = -levelSize; x <= levelSize; x++) {
                        if (filled || Math.abs(x) >= levelSize - 0.5 || Math.abs(z) >= levelSize - 0.5 || y === 0) {
                            setVoxelAt(cx + Math.round(x), cy - halfBase + y, cz + Math.round(z), color);
                        }
                    }
                }
            }
        }

        function generateCone(cx, cy, cz, radius, height, filled, color) {
            const r = radius / 2;
            for (let y = 0; y < height; y++) {
                const levelRadius = r * (1 - y / height);
                for (let z = -radius; z <= radius; z++) {
                    for (let x = -radius; x <= radius; x++) {
                        const dist = Math.sqrt(x * x + z * z);
                        if (filled ? dist <= levelRadius : (dist <= levelRadius && dist >= levelRadius - 1)) {
                            setVoxelAt(cx + x, cy - Math.floor(r) + y, cz + z, color);
                        }
                    }
                }
            }
        }

        function generateCylinder(cx, cy, cz, radius, height, filled, color) {
            const r = radius / 2;
            const halfH = Math.floor(height / 2);
            for (let y = -halfH; y < halfH; y++) {
                for (let z = -radius; z <= radius; z++) {
                    for (let x = -radius; x <= radius; x++) {
                        const dist = Math.sqrt(x * x + z * z);
                        if (filled ? dist <= r : (dist <= r && dist >= r - 1) || Math.abs(y) === halfH - 1) {
                            setVoxelAt(cx + x, cy + y, cz + z, color);
                        }
                    }
                }
            }
        }

        function setVoxelAt(x, y, z, color) {
            if (x >= 0 && x < editorState.width &&
                y >= 0 && y < editorState.height &&
                z >= 0 && z < editorState.depth) {
                editorState.voxelData[editorState.currentFrame][z][y][x] = color;
            }
        }

        // Export file
        function exportFile() {
            let data = generateHologlyphData();
            const compress = document.getElementById('exportCompress').checked;
            
            if (compress) {
                const original = data.length;
                data = compressGlyfFile(data);
                const stats = getCompressionStats(new Uint8Array(original), data);
                console.log(`Compression: ${(original/1024).toFixed(2)} KB ‚Üí ${(data.length/1024).toFixed(2)} KB (${stats.savings} savings)`);
            }
            
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const projectName = document.getElementById('projectName').value || 'Untitled';
            const suffix = compress ? '_compressed' : '';
            a.download = projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + suffix + '.glyf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            if (compress) {
                alert('Exported compressed file! File size reduced. The player will automatically decompress it when loading.');
            }
        }

        // Import file
        function importFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                let data = new Uint8Array(e.target.result);
                let header = parseHologlyphHeader(data);
                
                // Auto-decompress if compressed
                if (header.compressionType !== 0) {
                    console.log('Decompressing imported file...');
                    data = decompressGlyfFile(data);
                    header = parseHologlyphHeader(data);
                    console.log('Decompressed successfully');
                }

                editorState.width = header.width;
                editorState.height = header.height;
                editorState.depth = header.depth;
                editorState.frameCount = header.frameCount;
                editorState.frameDurationMs = header.frameDurationMs;
                editorState.loop = header.loop;
                editorState.currentFrame = 0;

                // Update UI
                document.getElementById('gridWidth').value = header.width;
                document.getElementById('gridHeight').value = header.height;
                document.getElementById('gridDepth').value = header.depth;
                document.getElementById('frameCount').value = header.frameCount;
                document.getElementById('frameDuration').value = header.frameDurationMs;
                document.getElementById('loopAnimation').checked = header.loop;

                // Parse voxel data
                editorState.voxelData = [];
                let offset = header.dataOffset;

                for (let f = 0; f < header.frameCount; f++) {
                    const frame = [];
                    for (let z = 0; z < header.depth; z++) {
                        const plane = [];
                        for (let y = 0; y < header.height; y++) {
                            const row = [];
                            for (let x = 0; x < header.width; x++) {
                                const px = data.subarray(offset, offset + 4);
                                const voxel = HSBAUtil.decodePixel(px);
                                row.push(voxel);
                                offset += 4;
                            }
                            plane.push(row);
                        }
                        frame.push(plane);
                    }
                    editorState.voxelData.push(frame);
                }

                updateFrameUI();
                updatePreview();
            };
            reader.readAsArrayBuffer(file);
        }

        // Frame navigation
        function goToFrame(frameIndex) {
            editorState.currentFrame = Math.max(0, Math.min(frameIndex, editorState.frameCount - 1));
            updateStats();
            updateFrameUI();
            
            // If onion skinning is enabled, regenerate data to update ghosts
            if (editorState.onionSkinEnabled) {
                updatePreview();
            } else if (player) {
                player.currentFrame = editorState.currentFrame;
                player.render();
            }
        }

        function addFrame() {
            if (editorState.frameCount >= 100) {
                alert('Maximum frame count reached');
                return;
            }

            // Create empty frame with all voxels transparent
            const emptyFrame = [];
            for (let z = 0; z < editorState.depth; z++) {
                const plane = [];
                for (let y = 0; y < editorState.height; y++) {
                    const row = [];
                    for (let x = 0; x < editorState.width; x++) {
                        row.push({ h: 0, s: 0, b: 0, a: 0 });
                    }
                    plane.push(row);
                }
                emptyFrame.push(plane);
            }
            
            // Insert after current frame
            editorState.voxelData.splice(editorState.currentFrame + 1, 0, emptyFrame);
            editorState.frameCount++;
            editorState.currentFrame++;
            
            document.getElementById('frameCount').value = editorState.frameCount;
            updateStats();
            updateFrameUI();
            updatePreview();
            triggerAutoSave();
        }

        function duplicateFrame() {
            if (editorState.frameCount >= 100) {
                alert('Maximum frame count reached');
                return;
            }

            const currentFrameData = JSON.parse(JSON.stringify(editorState.voxelData[editorState.currentFrame]));
            editorState.voxelData.splice(editorState.currentFrame + 1, 0, currentFrameData);
            editorState.frameCount++;
            editorState.currentFrame++;
            
            document.getElementById('frameCount').value = editorState.frameCount;
            updateStats();
            updateFrameUI();
            updatePreview();
            triggerAutoSave();
        }

        function deleteFrame() {
            if (editorState.frameCount <= 1) {
                alert('Cannot delete the last frame');
                return;
            }

            editorState.voxelData.splice(editorState.currentFrame, 1);
            editorState.frameCount--;
            editorState.currentFrame = Math.min(editorState.currentFrame, editorState.frameCount - 1);
            
            document.getElementById('frameCount').value = editorState.frameCount;
            updateStats();
            updateFrameUI();
            updatePreview();
            triggerAutoSave();
        }

        // Event listeners
        document.getElementById('createProject').addEventListener('click', initEditor);
        document.getElementById('generateShape').addEventListener('click', generateShape);
        document.getElementById('setVoxel').addEventListener('click', setVoxel);
        document.getElementById('clearVoxel').addEventListener('click', clearVoxel);
        document.getElementById('saveProject').addEventListener('click', () => saveProject());
        document.getElementById('exportFile').addEventListener('click', exportFile);
        document.getElementById('importFile').addEventListener('change', importFile);

        // Image import and rendering
        const TRACE_IMAGE_CONTAINER_WIDTH = 800;
        const TRACE_IMAGE_CONTAINER_HEIGHT = 800;

        function renderTraceImage() {
            const imgElement = document.getElementById('traceImage');
            if (!imgElement) return;
            
            // Hide HTML img element - we're using WebGL texture now
            imgElement.style.display = 'none';
            
            // If player exists and trace image changed, recreate player with new image
            if (player && editorState.traceImage) {
                // Update player properties
                player.traceImage = editorState.traceImage;
                player.traceImageOpacity = (editorState.traceImageOpacity || 50) / 100;
                player.traceImageScale = (editorState.traceImageScale || 100) / 100;
                player.traceImagePosX = editorState.traceImagePosX || 0;
                player.traceImagePosY = editorState.traceImagePosY || 0;
                
                // Reload texture if image changed
                if (player._loadTexture && player.gl) {
                    player._loadTexture(editorState.traceImage);
                }
                
                // Re-render
                if (player.render) {
                    player.render();
                }
            } else if (player && !editorState.traceImage) {
                // Clear trace image
                player.traceImage = null;
                if (player.render) {
                    player.render();
                }
            }
        }

        function importImageFile(file) {
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    editorState.traceImage = img;
                    document.getElementById('imageControls').style.display = 'block';
                    document.getElementById('imagePreviewContainer').style.display = 'block';
                    
                    // Update preview thumbnail
                    updateImagePreview(img);
                    
                    // Recreate player with new trace image
                    updatePreview();
                };
                img.onerror = function() {
                    alert('Failed to load image');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert('Failed to read image file');
            };
            reader.readAsDataURL(file);
        }

        function importImage(event) {
            const file = event.target.files[0];
            importImageFile(file);
        }

        function updateImagePreview(img) {
            const previewImg = document.getElementById('imagePreview');
            const previewInfo = document.getElementById('imagePreviewInfo');
            if (previewImg && previewInfo) {
                if (img) {
                    previewImg.src = img.src;
                    previewImg.style.display = 'block';
                    previewInfo.textContent = `${img.width} √ó ${img.height} pixels`;
                } else {
                    previewImg.src = '';
                    previewImg.style.display = 'none';
                    previewInfo.textContent = 'No image loaded';
                }
            }
        }

        function clearTraceImage() {
            editorState.traceImage = null;
            document.getElementById('imageControls').style.display = 'none';
            document.getElementById('imagePreviewContainer').style.display = 'none';
            document.getElementById('importImage').value = '';
            updateImagePreview(null);
            renderTraceImage();
        }

        // Image control event listeners
        document.getElementById('importImage').addEventListener('change', importImage);
        document.getElementById('clearImage').addEventListener('click', clearTraceImage);

        // Drag and drop support for image panel
        const imagePanel = document.getElementById('image-panel');
        const imagePreviewDropZone = document.getElementById('imagePreviewDropZone');
        const imagePreviewDropOverlay = document.getElementById('imagePreviewDropOverlay');
        let panelDragCounter = 0;

        if (imagePanel && imagePreviewDropZone) {
            // Prevent default drag behaviors on panel
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                imagePanel.addEventListener(eventName, function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            function isImageFileInPanel(e) {
                if (!e.dataTransfer.types.includes('Files')) return false;
                const items = Array.from(e.dataTransfer.items);
                return items.some(item => item.type.startsWith('image/'));
            }

            // Highlight drop zone in panel when dragging over
            imagePanel.addEventListener('dragenter', function(e) {
                panelDragCounter++;
                if (isImageFileInPanel(e)) {
                    if (imagePreviewDropOverlay) {
                        imagePreviewDropOverlay.style.display = 'flex';
                        imagePreviewDropOverlay.style.background = 'rgba(72, 199, 116, 0.2)';
                        imagePreviewDropOverlay.style.borderColor = '#48c774';
                    }
                }
            }, false);

            imagePanel.addEventListener('dragover', function(e) {
                if (isImageFileInPanel(e)) {
                    e.dataTransfer.dropEffect = 'copy';
                    if (imagePreviewDropOverlay) {
                        imagePreviewDropOverlay.style.display = 'flex';
                        imagePreviewDropOverlay.style.background = 'rgba(72, 199, 116, 0.2)';
                        imagePreviewDropOverlay.style.borderColor = '#48c774';
                    }
                } else {
                    e.dataTransfer.dropEffect = 'none';
                }
            }, false);

            // Remove highlight when leaving panel
            imagePanel.addEventListener('dragleave', function(e) {
                panelDragCounter--;
                if (panelDragCounter === 0) {
                    if (imagePreviewDropOverlay) {
                        imagePreviewDropOverlay.style.display = 'none';
                    }
                }
            }, false);

            // Handle dropped files in panel
            imagePanel.addEventListener('drop', function(e) {
                panelDragCounter = 0;
                if (imagePreviewDropOverlay) {
                    imagePreviewDropOverlay.style.display = 'none';
                }

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        importImageFile(file);
                    } else {
                        alert('Please drop an image file');
                    }
                }
            }, false);
        }

        // Drag and drop support for image import
        const canvasContainer = document.getElementById('canvasContainer');
        const dragDropOverlay = document.getElementById('dragDropOverlay');
        const dragDropOverlayAccepted = document.getElementById('dragDropOverlayAccepted');
        let dragCounter = 0; // Track drag enter/leave to handle nested elements
        
        if (canvasContainer) {
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function isImageFile(e) {
                if (!e.dataTransfer.types.includes('Files')) return false;
                const items = Array.from(e.dataTransfer.items);
                return items.some(item => item.type.startsWith('image/'));
            }
            
            // Highlight drop zone when dragging over
            canvasContainer.addEventListener('dragenter', function(e) {
                dragCounter++;
                if (isImageFile(e)) {
                    dragDropOverlayAccepted.style.display = 'flex';
                    dragDropOverlay.style.display = 'none';
                    canvasContainer.style.cursor = 'copy';
                } else if (e.dataTransfer.types.includes('Files')) {
                    dragDropOverlay.style.display = 'flex';
                    dragDropOverlayAccepted.style.display = 'none';
                    canvasContainer.style.cursor = 'not-allowed';
                }
            }, false);
            
            canvasContainer.addEventListener('dragover', function(e) {
                if (isImageFile(e)) {
                    dragDropOverlayAccepted.style.display = 'flex';
                    dragDropOverlay.style.display = 'none';
                    e.dataTransfer.dropEffect = 'copy';
                } else {
                    dragDropOverlay.style.display = 'flex';
                    dragDropOverlayAccepted.style.display = 'none';
                    e.dataTransfer.dropEffect = 'none';
                }
            }, false);
            
            // Remove highlight when leaving
            canvasContainer.addEventListener('dragleave', function(e) {
                dragCounter--;
                if (dragCounter === 0) {
                    dragDropOverlay.style.display = 'none';
                    dragDropOverlayAccepted.style.display = 'none';
                    canvasContainer.style.cursor = '';
                }
            }, false);
            
            // Handle dropped files
            canvasContainer.addEventListener('drop', function(e) {
                dragCounter = 0;
                dragDropOverlay.style.display = 'none';
                dragDropOverlayAccepted.style.display = 'none';
                canvasContainer.style.cursor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        importImageFile(file);
                    } else {
                        alert('Please drop an image file');
                    }
                }
            }, false);
        }
        
        document.getElementById('imageOpacity').addEventListener('input', function(e) {
            editorState.traceImageOpacity = parseInt(e.target.value);
            document.getElementById('imageOpacityValue').textContent = editorState.traceImageOpacity;
            renderTraceImage();
        });
        
        document.getElementById('imageScale').addEventListener('input', function(e) {
            editorState.traceImageScale = parseInt(e.target.value);
            document.getElementById('imageScaleValue').textContent = editorState.traceImageScale;
            renderTraceImage();
        });
        
        document.getElementById('imagePosX').addEventListener('input', function(e) {
            editorState.traceImagePosX = parseInt(e.target.value);
            document.getElementById('imagePosXValue').textContent = editorState.traceImagePosX;
            renderTraceImage();
        });
        
        document.getElementById('imagePosY').addEventListener('input', function(e) {
            editorState.traceImagePosY = parseInt(e.target.value);
            document.getElementById('imagePosYValue').textContent = editorState.traceImagePosY;
            renderTraceImage();
        });

        // Auto-save settings
        document.getElementById('autoSaveEnabled').addEventListener('change', saveSettings);

        // Color picker slider and input sync
        document.getElementById('colorHue').addEventListener('input', updateColorPreview);
        document.getElementById('colorSat').addEventListener('input', updateColorPreview);
        document.getElementById('colorBright').addEventListener('input', (e) => {
            document.getElementById('colorBrightValue').value = e.target.value;
            updateColorPreview();
        });
        document.getElementById('colorAlpha').addEventListener('input', (e) => {
            document.getElementById('colorAlphaValue').value = e.target.value;
            updateColorPreview();
        });

        document.getElementById('colorBrightValue').addEventListener('input', (e) => {
            document.getElementById('colorBright').value = e.target.value;
            updateColorPreview();
        });
        document.getElementById('colorAlphaValue').addEventListener('input', (e) => {
            document.getElementById('colorAlpha').value = e.target.value;
            updateColorPreview();
        });

        document.getElementById('frameSlider').addEventListener('input', (e) => {
            goToFrame(parseInt(e.target.value));
        });

        document.getElementById('currentFrameInput').addEventListener('input', (e) => {
            const frameNum = parseInt(e.target.value);
            if (frameNum >= 1 && frameNum <= editorState.frameCount) {
                goToFrame(frameNum - 1);
            }
        });

        document.getElementById('prevFrame').addEventListener('click', () => {
            goToFrame(editorState.currentFrame - 1);
        });

        document.getElementById('nextFrame').addEventListener('click', () => {
            goToFrame(editorState.currentFrame + 1);
        });

        document.getElementById('addFrame').addEventListener('click', addFrame);
        document.getElementById('duplicateFrame').addEventListener('click', duplicateFrame);
        document.getElementById('deleteFrame').addEventListener('click', deleteFrame);

        document.getElementById('playBtn').addEventListener('click', () => {
            if (player) player.play();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            if (player) player.pause();
        });

        // Camera rotation controls
        document.getElementById('cameraRotX').addEventListener('input', (e) => {
            if (player) {
                player.viewRotationX = parseFloat(e.target.value);
                player.render();
                drawAxisIndicator();
            }
        });

        document.getElementById('cameraRotY').addEventListener('input', (e) => {
            if (player) {
                player.viewRotationY = parseFloat(e.target.value);
                player.render();
                drawAxisIndicator();
            }
        });

        // Camera zoom controls
        document.getElementById('cameraZoom').addEventListener('input', (e) => {
            const zoom = parseFloat(e.target.value);
            document.getElementById('cameraZoomValue').value = zoom;
            if (player) {
                player.zoomLevel = zoom;
                player.render();
            }
        });

        document.getElementById('cameraZoomValue').addEventListener('input', (e) => {
            const zoom = parseFloat(e.target.value);
            document.getElementById('cameraZoom').value = zoom;
            if (player) {
                player.zoomLevel = zoom;
                player.render();
            }
        });

        document.getElementById('resetCamera').addEventListener('click', () => {
            document.getElementById('cameraRotX').value = 0.3;
            document.getElementById('cameraRotY').value = 0.6;
            document.getElementById('cameraZoom').value = 1.0;
            document.getElementById('cameraZoomValue').value = 1.0;
            if (player) {
                player.viewRotationX = 0.3;
                player.viewRotationY = 0.6;
                player.zoomLevel = 1.0;
                player.render();
            }
        });

        // Update shape dimension labels based on shape type
        document.getElementById('shapeType').addEventListener('change', (e) => {
            const shapeType = e.target.value;
            const widthLabel = document.getElementById('shapeWidthLabel');
            const heightContainer = document.getElementById('shapeHeightContainer');
            const depthContainer = document.getElementById('shapeDepthContainer');
            
            if (shapeType === 'cube') {
                widthLabel.textContent = 'Size';
                heightContainer.style.display = 'none';
                depthContainer.style.display = 'none';
            } else if (shapeType === 'sphere') {
                widthLabel.textContent = 'Radius';
                heightContainer.style.display = 'none';
                depthContainer.style.display = 'none';
            } else if (shapeType === 'pyramid' || shapeType === 'cone' || shapeType === 'cylinder') {
                widthLabel.textContent = 'Base Size';
                heightContainer.style.display = '';
                depthContainer.style.display = 'none';
            } else {
                widthLabel.textContent = 'Width';
                heightContainer.style.display = '';
                depthContainer.style.display = '';
            }
        });

        // Sync voxel position sliders with number inputs
        document.getElementById('voxelXSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelX').value = value;
            editorState.cursorPosition.x = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });
        document.getElementById('voxelYSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelY').value = value;
            editorState.cursorPosition.y = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });
        document.getElementById('voxelZSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelZ').value = value;
            editorState.cursorPosition.z = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });

        document.getElementById('voxelX').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelXSlider').value = value;
            editorState.cursorPosition.x = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });
        document.getElementById('voxelY').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelYSlider').value = value;
            editorState.cursorPosition.y = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });
        document.getElementById('voxelZ').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('voxelZSlider').value = value;
            editorState.cursorPosition.z = value;
            updateCursorDisplay();
            throttledPreviewUpdate();
        });

        // Initialize on load
        const settings = loadSettings();
        document.getElementById('autoSaveEnabled').checked = settings.autoSaveEnabled;
        
        // Load saved panel state
        loadPanelState();
        
        // Try to load last project, otherwise init new one
        if (!loadLastProject()) {
            initEditor();
        }
        
        initColorPicker();
        updateColorPreview();
        updateStats();
        updateSavedProjectsList();
        document.getElementById('shapeType').dispatchEvent(new Event('change'));
        setupAutoSave();
        setupInteractiveCanvas();
        updateCursorDisplay();
    </script>
</body>
</html>

